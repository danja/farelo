This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document.
Generated by Repomix on: 2025-03-30T10:22:48.186Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: public/main.bundle.js, docs, .env, knowledge, **/_*/**, **/webpack/*, *.log, **/*repopack*, **/*repomix*, **/*old*, **/*prompt*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------
User Provided Header:
-----------------------
Squirt repo

================================================================
Directory Structure
================================================================
public/
  demo.html
  index.html
  main.5e2c985a614e3bf02320.css
  main.bundle.js.LICENSE.txt
  manifest.json
  service-worker.js
src/
  css/
    form-styles.css
    styles.css
  html/
    index.html
  js/
    core/
      errors.js
      state.js
    services/
      rdf/
        rdf-extractor.js
        rdf-model.js
      sparql/
        test/
          spec/
            sparql.spec.js
        endpoints.js
        sparql.js
    ui/
      components/
        endpoints-list.js
        forms.js
        notifications.js
      views/
        settings.js
        wiki-editor.js
    utils/
      utils.js
    app.js
    router.js
test/
  spec/
    about.md
    sparql.spec.js
  setup.js
.babelrc
.gitignore
about.md
babel.config.json
endpoints.json
jasmine.json
jest.config.js
package.json
requirements_2025-03-28.md
tree.xml
webpack.config.js

================================================================
Files
================================================================

================
File: public/demo.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Post information to the web easily with Squirt">
    <title>Squirt - Link Extractor Demo</title>
    <style>
        :root {
            --primary-color: #3498db;
            --error-color: #e74c3c;
            --success-color: #2ecc71;
            --background-color: #f9f9f9;
            --text-color: #2c3e50;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: var(--background-color);
            color: var(--text-color);
        }
        
        header {
            background: white;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        main {
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        
        .form-field {
            margin-bottom: 1rem;
        }
        
        .form-field label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        
        .form-field input, 
        .form-field textarea, 
        .form-field select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        
        .form-field textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            cursor: pointer;
        }
        
        button:hover {
            opacity: 0.9;
        }
        
        #post-form {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .url-field-wrapper {
            display: flex;
            align-items: center;
        }
        
        .link-preview {
            margin-top: 1rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .preview-card {
            display: flex;
            flex-direction: column;
        }
        
        .preview-image {
            width: 100%;
            max-height: 200px;
            overflow: hidden;
        }
        
        .preview-image img {
            width: 100%;
            height: auto;
            object-fit: cover;
        }
        
        .preview-content {
            padding: 1rem;
        }
        
        .preview-title {
            margin: 0 0 0.5rem 0;
            font-size: 1.25rem;
        }
        
        .preview-description {
            margin: 0 0 0.5rem 0;
            font-size: 0.875rem;
            color: #666;
        }
        
        .preview-site {
            font-size: 0.75rem;
            color: #999;
        }
        
        .notifications-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .notification {
            padding: 10px 15px;
            border-radius: 4px;
            color: white;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .notification.success {
            background-color: var(--success-color);
        }
        
        .notification.error {
            background-color: var(--error-color);
        }
        
        .notification.info {
            background-color: var(--primary-color);
        }
        
        @media (min-width: 768px) {
            .preview-card {
                flex-direction: row;
            }
            
            .preview-image {
                width: 200px;
                max-height: none;
            }
            
            .preview-content {
                flex: 1;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Squirt - Link Extractor Demo</h1>
    </header>
    
    <main>
        <div id="post-view">
            <h2>Extract Link Data</h2>
            <p>Enter a URL below and click "Extract" to see metadata extraction in action.</p>
            <form id="post-form">
                <div class="form-field">
                    <label for="url">URL</label>
                    <div class="url-field-wrapper">
                        <input type="url" id="url" name="url" placeholder="https://example.com" required>
                        <button type="button" id="extract-button" style="margin-left: 8px;">Extract</button>
                    </div>
                </div>
                
                <div class="form-field">
                    <label for="title">Title</label>
                    <input type="text" id="title" name="title" placeholder="Enter a title">
                </div>
                
                <div class="form-field">
                    <label for="content">Content</label>
                    <textarea id="content" name="content" rows="5" placeholder="Enter your content here..."></textarea>
                </div>
                
                <div class="form-field">
                    <label for="tags">Tags (comma separated)</label>
                    <input type="text" id="tags" name="tags" placeholder="tag1, tag2, tag3">
                </div>
                
                <button type="submit">Save Link</button>
            </form>
            
            <div id="post-preview" style="margin-top: 20px;"></div>
        </div>
    </main>
    
    <div class="notifications-container" id="notifications"></div>
    
    <script>
        // Simple notification function
        function showNotification(message, type = 'info') {
            const container = document.getElementById('notifications');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            container.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Extract button functionality
        document.getElementById('extract-button').addEventListener('click', async () => {
            const urlInput = document.getElementById('url');
            const url = urlInput.value;
            
            if (!url) {
                showNotification('Please enter a valid URL', 'error');
                return;
            }
            
            const extractButton = document.getElementById('extract-button');
            extractButton.disabled = true;
            extractButton.textContent = 'Extracting...';
            
            showNotification('Extracting metadata...', 'info');
            
            try {
                // For demo, simulate API call with timeout
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                // Mock data based on common websites for demo
                let mockMetadata;
                
                if (url.includes('github.com')) {
                    mockMetadata = {
                        title: 'GitHub Repository',
                        description: 'A GitHub repository containing open source code for a web application.',
                        image: 'https://github.githubassets.com/images/modules/site/social-cards/github-social.png',
                        siteName: 'GitHub',
                        tags: ['github', 'open-source', 'code']
                    };
                } else if (url.includes('medium.com')) {
                    mockMetadata = {
                        title: 'How to Extract Metadata from Web Pages',
                        description: 'A comprehensive guide to extracting metadata from web pages using various techniques and tools.',
                        image: 'https://miro.medium.com/max/1200/1*S8rX7ZSZVm-Jsx4rW1bwRQ.jpeg',
                        siteName: 'Medium',
                        tags: ['metadata', 'web-development', 'tutorial']
                    };
                } else if (url.includes('wikipedia.org')) {
                    mockMetadata = {
                        title: 'Resource Description Framework - Wikipedia',
                        description: 'Resource Description Framework (RDF) is a family of World Wide Web Consortium (W3C) specifications originally designed as a metadata data model.',
                        image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/RDF_Schema_Example.svg/1200px-RDF_Schema_Example.svg.png',
                        siteName: 'Wikipedia',
                        tags: ['rdf', 'semantic-web', 'metadata']
                    };
                } else {
                    mockMetadata = {
                        title: 'Example Website',
                        description: 'This is a sample description that would normally be extracted from the actual webpage you provided.',
                        image: 'https://placehold.co/600x400',
                        siteName: new URL(url).hostname.replace('www.', ''),
                        tags: ['example', 'web', 'link']
                    };
                }
                
                // Fill the form with metadata
                document.getElementById('title').value = mockMetadata.title;
                document.getElementById('content').value = mockMetadata.description;
                document.getElementById('tags').value = mockMetadata.tags.join(', ');
                
                // Show preview
                document.getElementById('post-preview').innerHTML = `
                    <h3>Link Preview</h3>
                    <div class="link-preview">
                        <div class="preview-card">
                            <div class="preview-image">
                                <img src="${mockMetadata.image}" alt="${mockMetadata.title}">
                            </div>
                            <div class="preview-content">
                                <h3 class="preview-title">${mockMetadata.title}</h3>
                                <p class="preview-description">${mockMetadata.description}</p>
                                <span class="preview-site">${mockMetadata.siteName}</span>
                            </div>
                        </div>
                    </div>
                `;
                
                showNotification('Metadata extracted successfully', 'success');
            } catch (error) {
                showNotification('Failed to extract metadata', 'error');
                console.error(error);
            } finally {
                extractButton.disabled = false;
                extractButton.textContent = 'Extract';
            }
        });
        
        // Form submission
        document.getElementById('post-form').addEventListener('submit', (e) => {
            e.preventDefault();
            showNotification('Link saved successfully!', 'success');
            
            // In a real app, you would save the data to RDF store here
            console.log('Form submitted with data:', {
                url: document.getElementById('url').value,
                title: document.getElementById('title').value,
                content: document.getElementById('content').value,
                tags: document.getElementById('tags').value
            });
        });
    </script>
</body>
</html>

================
File: public/index.html
================
<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Post information to the web easily with Squirt"><meta name="theme-color" content="#3498db"><title>Squirt</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Squirt"><link rel="apple-touch-icon" href="/icons/apple-touch-icon.png"><script defer="defer" src="main.bundle.js"></script><link href="main.5e2c985a614e3bf02320.css" rel="stylesheet"></head><body><header><h1>Squirt</h1><nav><a href="#" data-view="post-view">Post</a> <a href="#" data-view="wiki-view">Wiki</a> <a href="#" data-view="developer-view">Developer</a> <a href="#" data-view="profile-view">Profile</a> <a href="#" data-view="settings-view">Settings</a></nav></header><main><div id="post-view" class="view"><h2>Create Post</h2><form id="post-form" class="form-group"><div class="form-field"><label for="post-type">Post Type</label> <select id="post-type" name="post-type" required><option value="entry">Entry</option><option value="link" selected="selected">Link</option></select></div><div class="form-fields"><div class="form-field"><label for="url">URL</label><div style="display: flex; align-items: center;"><input type="url" id="url" name="url" placeholder="https://example.com" required style="flex: 1;"> <button type="button" id="extract-metadata" class="extract-button" style="margin-left: 8px;">Extract</button></div></div><div class="form-field"><label for="title">Title</label> <input id="title" name="title" placeholder="Enter a title"></div><div class="form-field"><label for="content">Content</label> <textarea id="content" name="content" rows="5" placeholder="Enter your content here..."></textarea></div><div class="form-field"><label for="tags">Tags (comma separated)</label> <input id="tags" name="tags" placeholder="tag1, tag2, tag3"></div></div><button type="submit" class="button-primary">Post</button></form><div id="post-preview" style="margin-top: 20px;"></div></div><div id="wiki-view" class="view hidden"><h2>Wiki</h2><div class="wiki-editor"><div class="form-field"><label for="wiki-title">Title</label> <input id="wiki-title" name="title" required></div><div class="form-field"><label for="wiki-content">Content (Markdown supported)</label> <textarea id="wiki-content" name="content" rows="10" required></textarea></div><div class="form-field"><label for="wiki-tags">Tags (comma separated)</label> <input id="wiki-tags" name="tags" placeholder="tag1, tag2, tag3"></div><button type="button" id="save-wiki">Save</button></div><div class="wiki-entries"></div></div><div id="developer-view" class="view hidden"><h2>Developer Tools</h2><div class="developer-section"><h3>SPARQL Query</h3><div class="form-field"><textarea id="sparql-query" rows="10" placeholder="Enter SPARQL query..."></textarea></div><button type="button" id="run-query">Run Query</button><div id="query-results" class="results-container"></div></div></div><div id="profile-view" class="view hidden"><h2>Profile</h2><form id="profile-form" class="form-group"><div class="form-field"><label for="profile-name">Name</label> <input id="profile-name" name="name"></div><div class="form-field"><label for="profile-email">Email</label> <input type="email" id="profile-email" name="email"></div><div class="form-field"><label for="profile-bio">Bio</label> <textarea id="profile-bio" name="bio"></textarea></div><button type="submit">Save Profile</button></form></div><div id="settings-view" class="view hidden"><h2>Settings</h2><div class="settings-section"><h3>Appearance</h3><div class="form-field"><label for="theme-selector">Theme</label> <select id="theme-selector"><option value="light">Light</option><option value="dark">Dark</option><option value="system">System Preference</option></select></div></div><div class="settings-section"><h3>SPARQL Endpoints</h3><div id="endpoints-list"></div><form id="endpoint-form" class="form-group"><input id="endpoint-label" placeholder="Endpoint Label" required> <input type="url" id="endpoint-url" placeholder="Enter SPARQL endpoint URL" required> <button type="submit">Add Endpoint</button></form></div><div class="settings-section storage-section"><h3>Storage</h3><div id="storage-usage">Calculating storage usage...</div></div></div></main></body></html>

================
File: public/main.5e2c985a614e3bf02320.css
================
:root {
  --primary-color: #3498db;
  --error-color: #e74c3c;
  --success-color: #2ecc71;
  --background-color: #f9f9f9;
  --text-color: #2c3e50;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  line-height: 1.6;
  margin: 0;
  padding: 0;
  background: var(--background-color);
  color: var(--text-color);
}

header {
  background: white;
  padding: 1rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

nav {
  display: flex;
  gap: 1rem;
}

nav a {
  color: var(--text-color);
  text-decoration: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
}

nav a:hover {
  background: var(--background-color);
}

main {
  max-width: 800px;
  margin: 2rem auto;
  padding: 0 1rem;
}

.hidden {
  display: none;
}

/* Settings Styles */
.settings-section {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin-bottom: 2rem;
}

.settings-section h3 {
  margin-top: 0;
  margin-bottom: 1rem;
  color: var(--text-color);
}

.endpoint-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  border-bottom: 1px solid #eee;
}

.endpoint-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.endpoint-url {
  font-size: 0.875rem;
  color: #666;
  margin-top: 0.25rem;
}

.endpoint-status {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #999;
  transition: background-color 0.3s ease;
}

.endpoint-status.checking {
  animation: pulse 1.5s infinite;
  background: var(--primary-color);
}

.endpoint-status.active {
  background: var(--success-color);
}

.endpoint-status.inactive {
  background: var(--error-color);
}

.endpoint-label[contenteditable] {
  padding: 0.25rem;
  border-radius: 4px;
}

.endpoint-label[contenteditable]:focus {
  outline: 2px solid var(--primary-color);
  background: white;
}

.endpoint-actions {
  display: flex;
  gap: 0.5rem;
}

#endpoint-form {
  display: grid;
  grid-template-columns: 1fr 2fr auto;
  gap: 0.5rem;
  margin-top: 1rem;
}

@keyframes pulse {
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
}
/* Form Styles */
.form-field {
  margin-bottom: 1rem;
}

.form-field label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
}

.form-field input,
.form-field textarea,
.form-field select {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  font-size: 1rem;
  font-family: inherit;
}

.form-field textarea {
  min-height: 100px;
  resize: vertical;
}

.form-field input:focus,
.form-field textarea:focus,
.form-field select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

button[type="submit"],
.button-primary {
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s;
}

button[type="submit"]:hover,
.button-primary:hover {
  background-color: #2980b9;
}

/* Post form specific styles */
#post-form {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.form-fields {
  margin-top: 1rem;
}

/* Extract button */
.extract-button {
  margin-left: 8px;
  padding: 0.5rem 1rem;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.875rem;
}

.extract-button:hover {
  background-color: #2980b9;
}

.extract-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

/* Link preview */
.link-preview {
  margin-top: 1rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
}

.preview-card {
  display: flex;
  flex-direction: column;
  max-width: 100%;
}

.preview-image {
  width: 100%;
  max-height: 200px;
  overflow: hidden;
}

.preview-image img {
  width: 100%;
  height: auto;
  object-fit: cover;
}

.preview-content {
  padding: 1rem;
}

.preview-title {
  margin: 0 0 0.5rem 0;
  font-size: 1.25rem;
  color: var(--text-color);
}

.preview-description {
  margin: 0 0 0.5rem 0;
  font-size: 0.875rem;
  color: #666;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.preview-site {
  font-size: 0.75rem;
  color: #999;
}

@media (min-width: 768px) {
  .preview-card {
    flex-direction: row;
  }
  
  .preview-image {
    width: 200px;
    max-height: none;
  }
  
  .preview-content {
    flex: 1;
  }
}

================
File: public/main.bundle.js.LICENSE.txt
================
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

================
File: public/manifest.json
================
{
  "name": "Squirt",
  "short_name": "Squirt",
  "description": "Web posting, sharing and storing app",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#3498db",
  "icons": [
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "share_target": {
    "action": "/?share-target=1",
    "method": "GET",
    "enctype": "application/x-www-form-urlencoded",
    "params": {
      "title": "title",
      "text": "text",
      "url": "url"
    }
  }
}

================
File: public/service-worker.js
================
// Service Worker for Squirt PWA

const CACHE_NAME = 'squirt-cache-v1';
const assetsToCache = [
  '/',
  '/index.html',
  '/main.bundle.js',
  '/main.*.css',
  '/manifest.json'
];

// Install event - cache assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('Service Worker: Caching files');
        return cache.addAll(assetsToCache);
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('Service Worker: Clearing old cache');
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Fetch event - serve from cache or network
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((cachedResponse) => {
        // Return cached response if found
        if (cachedResponse) {
          return cachedResponse;
        }

        // Otherwise fetch from network
        return fetch(event.request)
          .then((response) => {
            // Only cache successful responses
            if (!response || response.status !== 200 || response.type !== 'basic') {
              return response;
            }

            // Clone the response
            const responseToCache = response.clone();

            // Add to cache
            caches.open(CACHE_NAME)
              .then((cache) => {
                cache.put(event.request, responseToCache);
              });

            return response;
          });
      })
  );
});

// Handle ShareTarget API for mobile devices
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  if (url.searchParams.has('share-target')) {
    event.respondWith(
      (async () => {
        try {
          // Get shared data
          const formData = await event.request.formData();
          const title = formData.get('title') || '';
          const text = formData.get('text') || '';
          const url = formData.get('url') || '';
          
          // Store the data for client retrieval
          const client = await self.clients.get(event.resultingClientId);
          client.postMessage({
            type: 'SHARE_TARGET_DATA',
            data: { title, text, url }
          });
          
          // Redirect to app
          return Response.redirect('/?share-received=1', 303);
        } catch (error) {
          console.error('Error handling share target:', error);
          return Response.redirect('/?share-error=1', 303);
        }
      })()
    );
  }
});

================
File: src/css/form-styles.css
================
/* Form Styles */
.form-field {
  margin-bottom: 1rem;
}

.form-field label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
}

.form-field input,
.form-field textarea,
.form-field select {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  font-size: 1rem;
  font-family: inherit;
}

.form-field textarea {
  min-height: 100px;
  resize: vertical;
}

.form-field input:focus,
.form-field textarea:focus,
.form-field select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

button[type="submit"],
.button-primary {
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s;
}

button[type="submit"]:hover,
.button-primary:hover {
  background-color: #2980b9;
}

/* Post form specific styles */
#post-form {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.form-fields {
  margin-top: 1rem;
}

/* Extract button */
.extract-button {
  margin-left: 8px;
  padding: 0.5rem 1rem;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.875rem;
}

.extract-button:hover {
  background-color: #2980b9;
}

.extract-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

/* Link preview */
.link-preview {
  margin-top: 1rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
}

.preview-card {
  display: flex;
  flex-direction: column;
  max-width: 100%;
}

.preview-image {
  width: 100%;
  max-height: 200px;
  overflow: hidden;
}

.preview-image img {
  width: 100%;
  height: auto;
  object-fit: cover;
}

.preview-content {
  padding: 1rem;
}

.preview-title {
  margin: 0 0 0.5rem 0;
  font-size: 1.25rem;
  color: var(--text-color);
}

.preview-description {
  margin: 0 0 0.5rem 0;
  font-size: 0.875rem;
  color: #666;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.preview-site {
  font-size: 0.75rem;
  color: #999;
}

@media (min-width: 768px) {
  .preview-card {
    flex-direction: row;
  }
  
  .preview-image {
    width: 200px;
    max-height: none;
  }
  
  .preview-content {
    flex: 1;
  }
}

================
File: src/css/styles.css
================
:root {
  --primary-color: #3498db;
  --error-color: #e74c3c;
  --success-color: #2ecc71;
  --background-color: #f9f9f9;
  --text-color: #2c3e50;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  line-height: 1.6;
  margin: 0;
  padding: 0;
  background: var(--background-color);
  color: var(--text-color);
}

header {
  background: white;
  padding: 1rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

nav {
  display: flex;
  gap: 1rem;
}

nav a {
  color: var(--text-color);
  text-decoration: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
}

nav a:hover {
  background: var(--background-color);
}

main {
  max-width: 800px;
  margin: 2rem auto;
  padding: 0 1rem;
}

.hidden {
  display: none;
}

/* Settings Styles */
.settings-section {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin-bottom: 2rem;
}

.settings-section h3 {
  margin-top: 0;
  margin-bottom: 1rem;
  color: var(--text-color);
}

.endpoint-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  border-bottom: 1px solid #eee;
}

.endpoint-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.endpoint-url {
  font-size: 0.875rem;
  color: #666;
  margin-top: 0.25rem;
}

.endpoint-status {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #999;
  transition: background-color 0.3s ease;
}

.endpoint-status.checking {
  animation: pulse 1.5s infinite;
  background: var(--primary-color);
}

.endpoint-status.active {
  background: var(--success-color);
}

.endpoint-status.inactive {
  background: var(--error-color);
}

.endpoint-label[contenteditable] {
  padding: 0.25rem;
  border-radius: 4px;
}

.endpoint-label[contenteditable]:focus {
  outline: 2px solid var(--primary-color);
  background: white;
}

.endpoint-actions {
  display: flex;
  gap: 0.5rem;
}

#endpoint-form {
  display: grid;
  grid-template-columns: 1fr 2fr auto;
  gap: 0.5rem;
  margin-top: 1rem;
}

@keyframes pulse {
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
}

================
File: src/html/index.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Post information to the web easily with Squirt">
    <meta name="theme-color" content="#3498db">
    <title>Squirt</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <!-- PWA manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS PWA support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Squirt">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
</head>

<body>
    <header>
        <h1>Squirt</h1>
        <nav>
            <a href="#" data-view="post-view">Post</a>
            <a href="#" data-view="wiki-view">Wiki</a>
            <a href="#" data-view="developer-view">Developer</a>
            <a href="#" data-view="profile-view">Profile</a>
            <a href="#" data-view="settings-view">Settings</a>
        </nav>
    </header>

    <main>
        <!-- Post View -->
        <div id="post-view" class="view">
            <h2>Create Post</h2>
            <form id="post-form" class="form-group">
                <div class="form-field">
                    <label for="post-type">Post Type</label>
                    <select id="post-type" name="post-type" required>
                        <option value="entry">Entry</option>
                        <option value="link" selected>Link</option>
                    </select>
                </div>
                
                <!-- Static form fields for Link type -->
                <div class="form-fields">
                    <div class="form-field">
                        <label for="url">URL</label>
                        <div style="display: flex; align-items: center;">
                            <input type="url" id="url" name="url" placeholder="https://example.com" required style="flex: 1;">
                            <button type="button" id="extract-metadata" class="extract-button" style="margin-left: 8px;">Extract</button>
                        </div>
                    </div>
                    
                    <div class="form-field">
                        <label for="title">Title</label>
                        <input type="text" id="title" name="title" placeholder="Enter a title">
                    </div>
                    
                    <div class="form-field">
                        <label for="content">Content</label>
                        <textarea id="content" name="content" rows="5" placeholder="Enter your content here..."></textarea>
                    </div>
                    
                    <div class="form-field">
                        <label for="tags">Tags (comma separated)</label>
                        <input type="text" id="tags" name="tags" placeholder="tag1, tag2, tag3">
                    </div>
                </div>
                
                <button type="submit" class="button-primary">Post</button>
            </form>
            
            <div id="post-preview" style="margin-top: 20px;"></div>
        </div>

        <!-- Wiki View -->
        <div id="wiki-view" class="view hidden">
            <h2>Wiki</h2>
            <div class="wiki-editor">
                <div class="form-field">
                    <label for="wiki-title">Title</label>
                    <input type="text" id="wiki-title" name="title" required>
                </div>
                <div class="form-field">
                    <label for="wiki-content">Content (Markdown supported)</label>
                    <textarea id="wiki-content" name="content" rows="10" required></textarea>
                </div>
                <div class="form-field">
                    <label for="wiki-tags">Tags (comma separated)</label>
                    <input type="text" id="wiki-tags" name="tags" placeholder="tag1, tag2, tag3">
                </div>
                <button type="button" id="save-wiki">Save</button>
            </div>
            <div class="wiki-entries"></div>
        </div>

        <!-- Developer View -->
        <div id="developer-view" class="view hidden">
            <h2>Developer Tools</h2>
            <div class="developer-section">
                <h3>SPARQL Query</h3>
                <div class="form-field">
                    <textarea id="sparql-query" rows="10" placeholder="Enter SPARQL query..."></textarea>
                </div>
                <button type="button" id="run-query">Run Query</button>
                <div id="query-results" class="results-container"></div>
            </div>
        </div>

        <!-- Profile View -->
        <div id="profile-view" class="view hidden">
            <h2>Profile</h2>
            <form id="profile-form" class="form-group">
                <div class="form-field">
                    <label for="profile-name">Name</label>
                    <input type="text" id="profile-name" name="name">
                </div>
                <div class="form-field">
                    <label for="profile-email">Email</label>
                    <input type="email" id="profile-email" name="email">
                </div>
                <div class="form-field">
                    <label for="profile-bio">Bio</label>
                    <textarea id="profile-bio" name="bio"></textarea>
                </div>
                <button type="submit">Save Profile</button>
            </form>
        </div>

        <!-- Settings View -->
        <div id="settings-view" class="view hidden">
            <h2>Settings</h2>
            
            <!-- Appearance Section -->
            <div class="settings-section">
                <h3>Appearance</h3>
                <div class="form-field">
                    <label for="theme-selector">Theme</label>
                    <select id="theme-selector">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="system">System Preference</option>
                    </select>
                </div>
            </div>
            
            <!-- Endpoints Section -->
            <div class="settings-section">
                <h3>SPARQL Endpoints</h3>
                <div id="endpoints-list"></div>
                <form id="endpoint-form" class="form-group">
                    <input type="text" id="endpoint-label" placeholder="Endpoint Label" required>
                    <input type="url" id="endpoint-url" placeholder="Enter SPARQL endpoint URL" required>
                    <button type="submit">Add Endpoint</button>
                </form>
            </div>
            
            <!-- Storage Section -->
            <div class="settings-section storage-section">
                <h3>Storage</h3>
                <div id="storage-usage">Calculating storage usage...</div>
            </div>
        </div>
    </main>
</body>

</html>

================
File: src/js/core/errors.js
================
/**
 * Custom application error class with additional details
 */
export class AppError extends Error {
    constructor(message, code, details = {}) {
        super(message);
        this.name = 'AppError';
        this.code = code;
        this.details = details;
    }
}

/**
 * SPARQL-specific error class
 */
export class SparqlError extends AppError {
    constructor(message, details = {}) {
        super(message, 'SPARQL_ERROR', details);
        this.name = 'SparqlError';
    }
}

/**
 * Network error class
 */
export class NetworkError extends AppError {
    constructor(message, details = {}) {
        super(message, 'NETWORK_ERROR', details);
        this.name = 'NetworkError';
    }
}

/**
 * Error handler for centralized error management
 */
export const ErrorHandler = {
    /**
     * Handle an error by logging it and optionally displaying a user-friendly message
     * @param {Error} error - The error to handle
     * @param {boolean} showToUser - Whether to show the error to the user
     */
    handle(error, showToUser = true) {
        console.error('Error:', error);
        
        // Determine if error should be shown to user
        if (showToUser) {
            // Use notification system if available
            if (typeof window.showNotification === 'function') {
                window.showNotification(this.getUserFriendlyMessage(error), 'error');
            } else {
                console.warn(this.getUserFriendlyMessage(error));
            }
        }
        
        // Track error for analytics
        this.trackError(error);
    },

    /**
     * Get a user-friendly error message
     * @param {Error} error - The error object
     * @returns {string} A user-friendly error message
     */
    getUserFriendlyMessage(error) {
        // Handle specific error types
        if (error instanceof SparqlError) {
            return 'SPARQL endpoint error. Please check your endpoint settings.';
        }
        
        if (error instanceof NetworkError) {
            return 'Network error. Please check your connection and try again.';
        }
        
        if (error instanceof AppError) {
            return error.message;
        }
        
        // Generic error checking by name/message
        if (error.name === 'NetworkError' || error.message.includes('network') || error.message.includes('fetch')) {
            return 'Network error. Please check your connection and try again.';
        }
        
        if (error.name === 'SyntaxError' || error.message.includes('syntax')) {
            return 'There was a syntax error in the request. Please try again.';
        }
        
        if (error.message.includes('endpoint') || error.message.includes('SPARQL')) {
            return 'SPARQL endpoint error. Please check your endpoint settings.';
        }
        
        // For security, don't expose detailed error messages to the user
        return error.userMessage || 'An error occurred. Please try again.';
    },
    
    /**
     * Track errors for analytics
     * @param {Error} error - The error to track
     */
    trackError(error) {
        // Basic implementation - can be expanded to send to a real analytics service
        if (window.errorLog === undefined) {
            window.errorLog = [];
        }
        
        window.errorLog.push({
            timestamp: new Date().toISOString(),
            message: error.message,
            stack: error.stack,
            type: error.name
        });
    },
    
    /**
     * Create a custom error with a user-friendly message
     * @param {string} message - Technical error message
     * @param {string} userMessage - User-friendly error message
     * @param {string} code - Error code
     * @returns {AppError} Custom error object
     */
    createError(message, userMessage, code = 'APP_ERROR') {
        const error = new AppError(message, code);
        error.userMessage = userMessage;
        return error;
    }
};

================
File: src/js/core/state.js
================
export class StateManager {
    constructor() {
        this.state = {
            endpoints: [],
            currentView: null,
            user: null,
            posts: [],
            drafts: []
        };
        this.listeners = new Map();
    }

    subscribe(key, callback) {
        if (!this.listeners.has(key)) {
            this.listeners.set(key, new Set());
        }
        this.listeners.get(key).add(callback);
    }

    update(key, value) {
        this.state[key] = value;
        if (this.listeners.has(key)) {
            this.listeners.get(key).forEach(callback => callback(value));
        }
    }

    get(key) {
        return this.state[key];
    }
}

export const state = new StateManager();

================
File: src/js/services/rdf/rdf-extractor.js
================
import rdf from 'rdf-ext';
import { generateNid } from '../../utils/utils.js';
import { namespaces } from '../../utils/utils.js';

export class RDFFormExtractor {
  constructor() {
    this.dataset = rdf.dataset();
  }

  async extract(form) {
    const formData = new FormData(form);
    const subject = rdf.namedNode(generateNid(formData.get('title')));

    for (const element of form.elements) {
      if (!element.name) continue;

      const predicate = rdf.namedNode(element.dataset.namespace + element.dataset.term);
      const object = this.createObject(element);

      if (object) {
        this.dataset.add(rdf.quad(subject, predicate, object));
      }
    }

    // Add type and timestamp
    const type = rdf.namedNode('http://purl.org/stuff/squirt/' + form.dataset.type);
    const now = new Date().toISOString();

    this.dataset.add(rdf.quad(
      subject,
      rdf.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
      type
    ));

    this.dataset.add(rdf.quad(
      subject,
      rdf.namedNode('http://purl.org/dc/terms/created'),
      rdf.literal(now, rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
    ));

    return this.dataset;
  }

  createObject(element) {
    const value = element.value.trim();
    if (!value) return null;

    switch (element.type) {
      case 'url':
        return rdf.namedNode(value);
      case 'number':
        return rdf.literal(value, rdf.namedNode('http://www.w3.org/2001/XMLSchema#decimal'));
      default:
        return rdf.literal(value);
    }
  }
}

/**
 * Extract metadata from a URL and create an RDF dataset
 * @param {string} url - The URL to extract metadata from
 * @returns {Promise<Object>} - Object containing dataset and metadata
 */
export async function extractFromUrl(url) {
  try {
    const metadata = await extractMetadataFromUrl(url);
    return {
      metadata,
      dataset: createDatasetFromMetadata(metadata)
    };
  } catch (error) {
    console.error('Error extracting from URL:', error);
    throw error;
  }
}

/**
 * Convert metadata to RDF dataset
 * @param {Object} metadata - The metadata object
 * @returns {Dataset} - RDF dataset
 */
export function createDatasetFromMetadata(metadata) {
  const dataset = rdf.dataset();
  const subject = rdf.namedNode(generateNid(metadata.url));
  
  // Add type - default to "link" type
  dataset.add(rdf.quad(
    subject,
    rdf.namedNode(namespaces.rdf + 'type'),
    rdf.namedNode(namespaces.squirt + 'link')
  ));
  
  // Add URL
  if (metadata.url) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.squirt + 'url'),
      rdf.namedNode(metadata.url)
    ));
  }
  
  // Add title
  if (metadata.title) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'title'),
      rdf.literal(metadata.title)
    ));
  }
  
  // Add description
  if (metadata.description) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'description'),
      rdf.literal(metadata.description)
    ));
  }
  
  // Add image
  if (metadata.image) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.squirt + 'image'),
      rdf.namedNode(metadata.image)
    ));
  }
  
  // Add site name
  if (metadata.siteName) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.squirt + 'siteName'),
      rdf.literal(metadata.siteName)
    ));
  }
  
  // Add author
  if (metadata.author) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'creator'),
      rdf.literal(metadata.author)
    ));
  }
  
  // Add date
  if (metadata.date) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'date'),
      rdf.literal(metadata.date, rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
    ));
  }
  
  // Add tags
  if (metadata.tags && Array.isArray(metadata.tags)) {
    metadata.tags.forEach(tag => {
      dataset.add(rdf.quad(
        subject,
        rdf.namedNode(namespaces.squirt + 'tag'),
        rdf.literal(tag)
      ));
    });
  }
  
  // Add creation timestamp
  const now = new Date().toISOString();
  dataset.add(rdf.quad(
    subject,
    rdf.namedNode(namespaces.dc + 'created'),
    rdf.literal(now, rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
  ));
  
  return dataset;
}

/**
 * Extract metadata from a URL
 * @param {string} url - The URL to extract metadata from
 * @returns {Promise<Object>} - The extracted metadata
 */
export async function extractMetadataFromUrl(url) {
  try {
    // Basic validation
    if (!url) {
      throw new Error('URL is required');
    }
    
    // Use a proxy or CORS-enabled service if needed
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    
    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch URL: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    const html = data.contents;
    
    // Parse the HTML using DOMParser
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Extract metadata
    const metadata = {
      url: url,
      title: extractTitle(doc),
      description: extractDescription(doc),
      image: extractImage(doc, url),
      siteName: extractSiteName(doc),
      type: extractType(doc),
      date: extractDate(doc),
      author: extractAuthor(doc),
      tags: extractTags(doc)
    };
    
    return metadata;
  } catch (error) {
    console.error('Error extracting metadata:', error);
    // Return basic metadata with the URL only as fallback
    return {
      url: url,
      title: extractBasicTitleFromUrl(url),
      error: error.message
    };
  }
}

/**
 * Extract title from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted title
 */
function extractTitle(doc) {
  // Try Open Graph title first
  const ogTitle = doc.querySelector('meta[property="og:title"]');
  if (ogTitle) {
    return ogTitle.getAttribute('content');
  }
  
  // Try Twitter title
  const twitterTitle = doc.querySelector('meta[name="twitter:title"]');
  if (twitterTitle) {
    return twitterTitle.getAttribute('content');
  }
  
  // Fall back to document title
  const docTitle = doc.querySelector('title');
  if (docTitle && docTitle.textContent) {
    return docTitle.textContent.trim();
  }
  
  // Fall back to first h1
  const h1 = doc.querySelector('h1');
  if (h1 && h1.textContent) {
    return h1.textContent.trim();
  }
  
  return '';
}

/**
 * Extract description from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted description
 */
function extractDescription(doc) {
  // Try Open Graph description
  const ogDesc = doc.querySelector('meta[property="og:description"]');
  if (ogDesc) {
    return ogDesc.getAttribute('content');
  }
  
  // Try Twitter description
  const twitterDesc = doc.querySelector('meta[name="twitter:description"]');
  if (twitterDesc) {
    return twitterDesc.getAttribute('content');
  }
  
  // Try meta description
  const metaDesc = doc.querySelector('meta[name="description"]');
  if (metaDesc) {
    return metaDesc.getAttribute('content');
  }
  
  return '';
}

/**
 * Extract image from document
 * @param {Document} doc - The HTML document
 * @param {string} baseUrl - The base URL for resolving relative URLs
 * @returns {string} - The extracted image URL
 */
function extractImage(doc, baseUrl) {
  // Try Open Graph image
  const ogImage = doc.querySelector('meta[property="og:image"]');
  if (ogImage) {
    const imageSrc = ogImage.getAttribute('content');
    return resolveUrl(imageSrc, baseUrl);
  }
  
  // Try Twitter image
  const twitterImage = doc.querySelector('meta[name="twitter:image"]');
  if (twitterImage) {
    const imageSrc = twitterImage.getAttribute('content');
    return resolveUrl(imageSrc, baseUrl);
  }
  
  // Try to find a prominent image
  const articleImage = doc.querySelector('article img, .content img, .post img');
  if (articleImage) {
    const imageSrc = articleImage.getAttribute('src');
    return resolveUrl(imageSrc, baseUrl);
  }
  
  return '';
}

/**
 * Extract site name from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted site name
 */
function extractSiteName(doc) {
  // Try Open Graph site name
  const ogSite = doc.querySelector('meta[property="og:site_name"]');
  if (ogSite) {
    return ogSite.getAttribute('content');
  }
  
  // Try schema.org WebSite name
  const schemaWebsite = doc.querySelector('[itemtype="http://schema.org/WebSite"] [itemprop="name"]');
  if (schemaWebsite) {
    return schemaWebsite.textContent.trim();
  }
  
  return '';
}

/**
 * Extract content type from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted type
 */
function extractType(doc) {
  // Try Open Graph type
  const ogType = doc.querySelector('meta[property="og:type"]');
  if (ogType) {
    return ogType.getAttribute('content');
  }
  
  // Try schema.org type
  const schemaType = doc.querySelector('[itemtype]');
  if (schemaType) {
    const type = schemaType.getAttribute('itemtype');
    return type.replace('http://schema.org/', '');
  }
  
  return 'website';
}

/**
 * Extract published date from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted date
 */
function extractDate(doc) {
  // Try published date meta
  const metaDate = doc.querySelector('meta[property="article:published_time"]');
  if (metaDate) {
    return metaDate.getAttribute('content');
  }
  
  // Try schema.org date published
  const schemaDate = doc.querySelector('[itemprop="datePublished"]');
  if (schemaDate) {
    return schemaDate.getAttribute('content') || schemaDate.textContent.trim();
  }
  
  // Try looking for a time element
  const timeElement = doc.querySelector('time');
  if (timeElement) {
    return timeElement.getAttribute('datetime') || timeElement.textContent.trim();
  }
  
  return '';
}

/**
 * Extract author from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted author
 */
function extractAuthor(doc) {
  // Try meta author
  const metaAuthor = doc.querySelector('meta[name="author"]');
  if (metaAuthor) {
    return metaAuthor.getAttribute('content');
  }
  
  // Try Open Graph article author
  const ogAuthor = doc.querySelector('meta[property="article:author"]');
  if (ogAuthor) {
    return ogAuthor.getAttribute('content');
  }
  
  // Try schema.org author
  const schemaAuthor = doc.querySelector('[itemprop="author"] [itemprop="name"]');
  if (schemaAuthor) {
    return schemaAuthor.textContent.trim();
  }
  
  // Try basic byline patterns
  const byline = doc.querySelector('.byline, .author');
  if (byline) {
    return byline.textContent.trim().replace(/^By\s+/i, '');
  }
  
  return '';
}

/**
 * Extract tags/keywords from document
 * @param {Document} doc - The HTML document
 * @returns {string[]} - The extracted tags
 */
function extractTags(doc) {
  const tags = [];
  
  // Try meta keywords
  const metaKeywords = doc.querySelector('meta[name="keywords"]');
  if (metaKeywords) {
    const keywordsStr = metaKeywords.getAttribute('content');
    if (keywordsStr) {
      tags.push(...keywordsStr.split(',').map(tag => tag.trim()));
    }
  }
  
  // Try article:tag
  const articleTags = doc.querySelectorAll('meta[property="article:tag"]');
  articleTags.forEach(tag => {
    tags.push(tag.getAttribute('content'));
  });
  
  // Try looking for tag links
  const tagLinks = doc.querySelectorAll('.tags a, .categories a, .topics a');
  tagLinks.forEach(link => {
    tags.push(link.textContent.trim());
  });
  
  return [...new Set(tags)]; // Remove duplicates
}

/**
 * Helper function to resolve relative URLs
 * @param {string} url - The URL to resolve
 * @param {string} base - The base URL
 * @returns {string} - The resolved URL
 */
function resolveUrl(url, base) {
  if (!url) return '';
  try {
    return new URL(url, base).href;
  } catch (e) {
    return url;
  }
}

/**
 * Extract a basic title from the URL if nothing else is available
 * @param {string} url - The URL
 * @returns {string} - A title derived from the URL
 */
function extractBasicTitleFromUrl(url) {
  try {
    const urlObj = new URL(url);
    const path = urlObj.pathname;
    
    // Get the last part of the path
    const parts = path.split('/').filter(Boolean);
    
    if (parts.length > 0) {
      // Get the last part and clean it up
      const lastPart = parts[parts.length - 1]
        .replace(/\.html$|\.php$|\.aspx$/, '')
        .replace(/-|_/g, ' ');
      
      // Capitalize first letter of each word
      return lastPart
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }
    
    // Fall back to domain if no path
    return urlObj.hostname.replace('www.', '');
  } catch (e) {
    // If all fails, return a portion of the URL
    return url.substring(0, 50) + (url.length > 50 ? '...' : '');
  }
}

================
File: src/js/services/rdf/rdf-model.js
================
import rdf from 'rdf-ext';
import N3Parser from '@rdfjs/parser-n3';
import { namespaces, generateNid } from '../../utils/utils.js';
import { state } from '../../core/state.js';
import { querySparql, postToSparql } from '../sparql/sparql.js';

export class RDFModel {
  constructor() {
    this.parser = new N3Parser();
    this.ns = {};
    
    // Initialize namespaces
    Object.entries(namespaces).forEach(([prefix, uri]) => {
      this.ns[prefix] = rdf.namespace(uri);
    });

    // Load any cached data on initialization
    this.loadCachedData();
  }

  async loadCachedData() {
    try {
      const cachedData = localStorage.getItem('squirt_rdf_cache');
      if (cachedData) {
        const dataset = await this.parseFromString(cachedData);
        state.update('rdfDataset', dataset);
      } else {
        state.update('rdfDataset', rdf.dataset());
      }
    } catch (error) {
      console.error('Error loading cached RDF data:', error);
      state.update('rdfDataset', rdf.dataset());
    }
  }

  saveToCache(dataset) {
    try {
      localStorage.setItem('squirt_rdf_cache', dataset.toString());
    } catch (error) {
      console.error('Error caching RDF data:', error);
    }
  }

  async parseFromString(turtleString) {
    try {
      const quads = [];
      const parser = this.parser;
      
      return new Promise((resolve, reject) => {
        const stream = parser.import(rdf.stringToStream(turtleString));
        
        stream.on('data', quad => {
          quads.push(quad);
        });
        
        stream.on('error', error => {
          reject(error);
        });
        
        stream.on('end', () => {
          resolve(rdf.dataset(quads));
        });
      });
    } catch (error) {
      console.error('Error parsing RDF data:', error);
      throw error;
    }
  }

  /**
   * Create a new post in the RDF dataset
   * @param {Object} postData - The post data
   * @param {string} postData.type - The post type (e.g., 'link', 'entry', 'wiki')
   * @param {string} postData.content - The content of the post
   * @param {string} [postData.title] - Optional title
   * @param {string[]} [postData.tags] - Optional array of tags
   * @param {string} [postData.customId] - Optional custom ID (for updates)
   * @param {string} [postData.graph] - Optional named graph URI
   * @returns {string} The ID of the created post
   */
  createPost(postData) {
    const dataset = state.get('rdfDataset') || rdf.dataset();
    
    // Use custom ID if provided (useful for updates), otherwise generate one
    const postId = postData.customId || generateNid(postData.content);
    const subject = rdf.namedNode(postId);
    
    // Create a named graph for this post if specified
    const graph = postData.graph ? 
      rdf.namedNode(postData.graph) : 
      null;
    
    // Helper function to add quad with optional graph
    const addQuad = (s, p, o) => {
      if (graph) {
        dataset.add(rdf.quad(s, p, o, graph));
      } else {
        dataset.add(rdf.quad(s, p, o));
      }
    };
    
    // Add RDF type
    addQuad(
      subject,
      this.ns.rdf('type'),
      this.ns.squirt(postData.type)
    );
    
    // Add content
    addQuad(
      subject,
      this.ns.squirt('content'),
      rdf.literal(postData.content)
    );
    
    // Add creation date
    addQuad(
      subject,
      this.ns.dc('created'),
      rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
    );
    
    // Add title if provided
    if (postData.title) {
      addQuad(
        subject,
        this.ns.dc('title'),
        rdf.literal(postData.title)
      );
    }
    
    // Add tags if provided
    if (postData.tags && Array.isArray(postData.tags)) {
      postData.tags.forEach(tag => {
        addQuad(
          subject,
          this.ns.squirt('tag'),
          rdf.literal(tag)
        );
      });
    }
    
    // Add URL if it's a link post and has a URL
    if (postData.type === 'link' && postData.url) {
      addQuad(
        subject,
        this.ns.squirt('url'),
        rdf.namedNode(postData.url)
      );
    }
    
    // Add wiki-specific fields
    if (postData.type === 'wiki') {
      // Add last modified date
      addQuad(
        subject,
        this.ns.dc('modified'),
        rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
      );
    }
    
    // Update state with new dataset
    state.update('rdfDataset', dataset);
    
    // Save to cache
    this.saveToCache(dataset);
    
    return postId;
  }

  /**
   * Get posts from the dataset
   * @param {Object} [options] - Query options
   * @param {string} [options.type] - Filter by post type
   * @param {string} [options.tag] - Filter by tag
   * @param {number} [options.limit] - Max number of posts to return
   * @param {string} [options.graph] - Filter by named graph
   * @returns {Array} Array of post objects
   */
  getPosts(options = {}) {
    const dataset = state.get('rdfDataset');
    if (!dataset) return [];
    
    let posts = new Map();
    
    // Find all posts
    const postTypePattern = this.ns.rdf('type');
    
    // Create matching options for graph filtering
    const matchOptions = {};
    if (options.graph) {
      matchOptions.graph = rdf.namedNode(options.graph);
    }
    
    // Get all subjects that are posts
    dataset.match(null, postTypePattern, null, options.graph ? rdf.namedNode(options.graph) : null).forEach(quad => {
      const postType = quad.object.value.split('/').pop();
      
      // Skip if filtering by type and this doesn't match
      if (options.type && postType !== options.type) return;
      
      const postId = quad.subject.value;
      const graphId = quad.graph?.value || null;
      
      if (!posts.has(postId)) {
        posts.set(postId, {
          id: postId,
          type: postType,
          graph: graphId,
          tags: []
        });
      }
    });
    
    // Now populate post details for the matched posts
    posts.forEach((post, id) => {
      const subject = rdf.namedNode(id);
      const graph = post.graph ? rdf.namedNode(post.graph) : null;
      
      // Get content
      dataset.match(subject, this.ns.squirt('content'), null, graph).forEach(quad => {
        post.content = quad.object.value;
      });
      
      // Get title
      dataset.match(subject, this.ns.dc('title'), null, graph).forEach(quad => {
        post.title = quad.object.value;
      });
      
      // Get created date
      dataset.match(subject, this.ns.dc('created'), null, graph).forEach(quad => {
        post.created = quad.object.value;
      });
      
      // Get modified date (primarily for wiki entries)
      dataset.match(subject, this.ns.dc('modified'), null, graph).forEach(quad => {
        post.modified = quad.object.value;
      });
      
      // Get tags
      dataset.match(subject, this.ns.squirt('tag'), null, graph).forEach(quad => {
        post.tags.push(quad.object.value);
      });
      
      // Get URL for link posts
      dataset.match(subject, this.ns.squirt('url'), null, graph).forEach(quad => {
        post.url = quad.object.value;
      });
    });
    
    // Filter by tag if needed
    if (options.tag) {
      posts = new Map(
        Array.from(posts.entries()).filter(([_, post]) => 
          post.tags.includes(options.tag)
        )
      );
    }
    
    // Convert to array and sort by date (newest first)
    // Use modified date if available (for wiki entries), otherwise use created date
    let postsArray = Array.from(posts.values())
      .sort((a, b) => {
        const dateA = a.modified ? new Date(a.modified) : new Date(a.created);
        const dateB = b.modified ? new Date(b.modified) : new Date(b.created);
        return dateB - dateA;
      });
    
    // Apply limit if specified
    if (options.limit && options.limit > 0) {
      postsArray = postsArray.slice(0, options.limit);
    }
    
    return postsArray;
  }

  /**
   * Synchronize local RDF data with remote SPARQL endpoint
   */
  async syncWithEndpoint() {
    const dataset = state.get('rdfDataset');
    if (!dataset || dataset.size === 0) return;
    
    try {
      await postToSparql(dataset);
      console.log('Data synchronized with SPARQL endpoint');
    } catch (error) {
      console.error('Failed to sync with SPARQL endpoint:', error);
      throw error;
    }
  }

  /**
   * Load posts from the SPARQL endpoint
   */
  async loadFromEndpoint() {
    try {
      const query = `
        PREFIX rdf: <${namespaces.rdf}>
        PREFIX squirt: <${namespaces.squirt}>
        PREFIX dc: <${namespaces.dc}>
        
        CONSTRUCT {
          ?s ?p ?o .
        }
        WHERE {
          ?s rdf:type ?type .
          FILTER(STRSTARTS(STR(?type), "${namespaces.squirt}"))
          ?s ?p ?o .
        }
      `;
      
      const response = await querySparql(query);
      
      if (response && response.results) {
        const dataset = await this.parseFromString(response.results);
        state.update('rdfDataset', dataset);
        this.saveToCache(dataset);
        console.log('Loaded data from SPARQL endpoint');
      }
    } catch (error) {
      console.error('Failed to load data from SPARQL endpoint:', error);
      throw error;
    }
  }

  /**
   * Delete a post from the dataset
   * @param {string} postId - The ID of the post to delete
   * @returns {boolean} Success status
   */
  deletePost(postId) {
    const dataset = state.get('rdfDataset');
    if (!dataset) return false;
    
    const subject = rdf.namedNode(postId);
    
    // Find all quads with this subject and remove them
    const quadsToRemove = dataset.match(subject);
    
    if (quadsToRemove.size === 0) return false;
    
    quadsToRemove.forEach(quad => {
      dataset.delete(quad);
    });
    
    // Update state
    state.update('rdfDataset', dataset);
    
    // Save to cache
    this.saveToCache(dataset);
    
    return true;
  }
}

// Export a singleton instance
export const rdfModel = new RDFModel();

================
File: src/js/services/sparql/test/spec/sparql.spec.js
================
import { postToSparql, querySparql } from '../../src/js/services/sparql/sparql.js';
import rdf from 'rdf-ext';

describe('SPARQL Operations', () => {
  const testDataset = rdf.dataset();
  const testSubject = rdf.namedNode('http://example.org/test');
  const testPredicate = rdf.namedNode('http://example.org/name');
  const testObject = rdf.literal('Test Entry');

  beforeEach(() => {
    testDataset.add(rdf.quad(testSubject, testPredicate, testObject));
  });

  it('should successfully post data to SPARQL endpoint', async () => {
    try {
      const result = await postToSparql(testDataset);
      expect(result).toBe(true);
    } catch (error) {
      fail('Should not throw error: ' + error.message);
    }
  });

  it('should verify posted data with query', async () => {
    const query = `
      SELECT ?o 
      WHERE { 
        <http://example.org/test> <http://example.org/name> ?o .
      }
    `;

    try {
      const result = await querySparql(query);
      expect(result.results.bindings.length).toBeGreaterThan(0);
      expect(result.results.bindings[0].o.value).toBe('Test Entry');
    } catch (error) {
      fail('Should not throw error: ' + error.message);
    }
  });

  it('should handle SPARQL syntax errors gracefully', async () => {
    const badQuery = 'SELECT * WHERE { INVALID SYNTAX }';
    
    try {
      await querySparql(badQuery);
      fail('Should throw error for invalid query');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toMatch(/SPARQL query failed: 400 Parse error:/);
      expect(error.message).toContain('SELECT * WHERE { INVALID SYNTAX }');
      expect(error.message).toMatch(/Encountered " "in" "IN "" at line 1, column \d+/);
    }
  });

  it('should handle network errors gracefully', async () => {
    const badEndpoint = 'http://nonexistent-endpoint:3030/sparql';
    
    try {
      await fetch(badEndpoint);
      fail('Should throw error for network failure');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toContain('fetch failed');
    }
  });

  it('should handle empty dataset gracefully', async () => {
    const emptyDataset = rdf.dataset();
    try {
      const result = await postToSparql(emptyDataset);
      expect(result).toBe(true);
    } catch (error) {
      fail('Should not throw error for empty dataset: ' + error.message);
    }
  });
});

================
File: src/js/services/sparql/endpoints.js
================
import { state } from '../../core/state.js';
import { namespaces } from '../../utils/utils.js';
import { testEndpoint } from './sparql.js';
import { ErrorHandler } from '../../core/errors.js';

export class EndpointManager {
    constructor() {
        this.STORAGE_KEY = 'squirt_endpoints';
        this.statusCheckInterval = 60000; // 1 minute
    }

    async initialize() {
        try {
            // First try to load endpoints from the JSON file
            const endpointsFromFile = await this.loadFromFile();
            
            // Then try to load from localStorage (which may have user customizations)
            const storedEndpoints = this.loadFromStorage();
            
            // Merge the endpoints, giving preference to stored ones
            let endpoints = endpointsFromFile;
            
            if (storedEndpoints && storedEndpoints.length > 0) {
                // Keep existing endpoints from storage and add any new ones from file
                const storedUrls = new Set(storedEndpoints.map(e => e.url));
                const newEndpoints = endpointsFromFile.filter(e => !storedUrls.has(e.url));
                
                endpoints = [...storedEndpoints, ...newEndpoints];
            }
            
            if (!endpoints || endpoints.length === 0) {
                endpoints = this.getDefaultEndpoints();
            }
            
            state.update('endpoints', endpoints);
            this.startStatusChecks();
        } catch (error) {
            ErrorHandler.handle(error);
            const fallback = this.getDefaultEndpoints();
            state.update('endpoints', fallback);
            this.startStatusChecks();
        }
    }

    loadFromStorage() {
        try {
            const stored = localStorage.getItem(this.STORAGE_KEY);
            return stored ? JSON.parse(stored) : null;
        } catch (error) {
            console.error('Error loading endpoints from storage:', error);
            return null;
        }
    }

    async loadFromFile() {
        try {
            const response = await fetch('/endpoint.json');
            if (!response.ok) {
                throw new Error('Failed to load endpoints from file');
            }
            
            const endpoints = await response.json();
            
            // Map the structure to match our internal format
            return endpoints.map(endpoint => ({
                url: endpoint.url,
                label: endpoint.name,
                type: endpoint.type,
                credentials: endpoint.credentials,
                status: 'unknown'
            }));
        } catch (error) {
            console.error('Error loading endpoints from file:', error);
            throw error;
        }
    }

    getDefaultEndpoints() {
        return [
            { 
                url: 'http://localhost:3030/squirt/query',
                label: 'Local Query Endpoint',
                type: 'query',
                status: 'unknown'
            },
            {
                url: 'http://localhost:3030/squirt/update',
                label: 'Local Update Endpoint',
                type: 'update',
                status: 'unknown'
            }
        ];
    }

    startStatusChecks() {
        const checkAll = async () => {
            const endpoints = state.get('endpoints');
            
            if (!endpoints || endpoints.length === 0) return;
            
            for (const endpoint of endpoints) {
                try {
                    const status = await testEndpoint(endpoint.url, endpoint.credentials);
                    endpoint.status = status ? 'active' : 'inactive';
                    endpoint.lastChecked = new Date().toISOString();
                } catch (error) {
                    console.error(`Error checking endpoint ${endpoint.url}:`, error);
                    endpoint.status = 'inactive';
                }
            }
            
            state.update('endpoints', [...endpoints]);
            this.saveToStorage();
        };

        // Run immediately and then on interval
        checkAll();
        setInterval(checkAll, this.statusCheckInterval);
    }

    saveToStorage() {
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(state.get('endpoints')));
        } catch (error) {
            console.error('Error saving endpoints to storage:', error);
        }
    }

    addEndpoint(url, label, type = 'query', credentials = null) {
        const endpoints = state.get('endpoints') || [];
        
        // Check if endpoint with same URL already exists
        if (endpoints.some(e => e.url === url)) {
            throw new Error(`Endpoint with URL ${url} already exists`);
        }
        
        endpoints.push({ 
            url, 
            label, 
            type, 
            credentials,
            status: 'unknown', 
            lastChecked: null 
        });
        
        state.update('endpoints', endpoints);
        this.saveToStorage();
        
        // Check the status immediately
        this.checkEndpoint(url, credentials).then(status => {
            this.updateEndpoint(url, { 
                status: status ? 'active' : 'inactive',
                lastChecked: new Date().toISOString()
            });
        });
    }

    async checkEndpoint(url, credentials = null) {
        return testEndpoint(url, credentials);
    }

    removeEndpoint(url) {
        const endpoints = state.get('endpoints').filter(e => e.url !== url);
        state.update('endpoints', endpoints);
        this.saveToStorage();
    }

    updateEndpoint(url, updates) {
        const endpoints = state.get('endpoints').map(e => 
            e.url === url ? { ...e, ...updates } : e
        );
        state.update('endpoints', endpoints);
        this.saveToStorage();
    }

    getActiveEndpoint(type) {
        const endpoints = state.get('endpoints');
        return endpoints.find(e => e.type === type && e.status === 'active');
    }
}

================
File: src/js/services/sparql/sparql.js
================
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';

/**
 * Get the active endpoint URL for a specific type (query or update)
 * @param {string} type - The endpoint type: 'query' or 'update'
 * @returns {Object|null} The endpoint object or null if not found
 */
export function getEndpoint(type) {
  const endpoints = state.get('endpoints') || [];
  const endpoint = endpoints.find(e => e.type === type && e.status === 'active');
  
  if (!endpoint) {
    throw new Error(`No active ${type} endpoint available`);
  }
  
  return endpoint;
}

/**
 * Post RDF data to the SPARQL update endpoint
 * @param {Dataset} dataset - The RDF dataset to post
 * @returns {Promise<boolean>} Success status
 */
export async function postToSparql(dataset) {
  if (!dataset) {
    throw new Error('Dataset is required');
  }

  const endpoint = getEndpoint('update');
  const insertQuery = `
    INSERT DATA {
      ${dataset.toString()}
    }
  `;

  try {
    const headers = {
      'Content-Type': 'application/sparql-update',
      'Accept': '*/*'
    };
    
    // Add basic auth if credentials exist
    if (endpoint.credentials) {
      const { user, password } = endpoint.credentials;
      const auth = btoa(`${user}:${password}`);
      headers['Authorization'] = `Basic ${auth}`;
    }

    const response = await fetch(endpoint.url, {
      method: 'POST',
      headers,
      mode: 'cors',
      body: insertQuery
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`SPARQL update failed: ${response.status} ${errorText}`);
    }
    return true;
  } catch (error) {
    ErrorHandler.handle(error);
    throw error;
  }
}

/**
 * Query the SPARQL endpoint
 * @param {string} query - The SPARQL query string
 * @returns {Promise<Object>} Query results
 */
export async function querySparql(query) {
  if (!query) {
    throw new Error('Query is required');
  }

  const endpoint = getEndpoint('query');

  try {
    const headers = {
      'Content-Type': 'application/sparql-query',
      'Accept': 'application/json'
    };
    
    // Add basic auth if credentials exist
    if (endpoint.credentials) {
      const { user, password } = endpoint.credentials;
      const auth = btoa(`${user}:${password}`);
      headers['Authorization'] = `Basic ${auth}`;
    }

    const response = await fetch(endpoint.url, {
      method: 'POST',
      headers,
      mode: 'cors',
      body: query
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`SPARQL query failed: ${response.status} ${errorText}\n${query}`);
    }

    return response.json();
  } catch (error) {
    ErrorHandler.handle(error);
    throw error;
  }
}

/**
 * Test if a SPARQL endpoint is alive and responding
 * @param {string} url - The endpoint URL to test
 * @param {Object} [credentials] - Optional credentials for basic auth
 * @returns {Promise<boolean>} True if endpoint is alive
 */
export async function testEndpoint(url, credentials) {
  try {
    const headers = {
      'Accept': 'application/json'
    };
    
    if (credentials) {
      const { user, password } = credentials;
      const auth = btoa(`${user}:${password}`);
      headers['Authorization'] = `Basic ${auth}`;
    }

    // Use a minimal ASK query to test if the endpoint is alive
    const query = 'ASK { ?s ?p ?o } LIMIT 1';
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        ...headers,
        'Content-Type': 'application/sparql-query'
      },
      mode: 'cors',
      body: query
    });

    return response.ok;
  } catch (error) {
    console.error('Endpoint test failed:', error);
    return false;
  }
}

================
File: src/js/ui/components/endpoints-list.js
================
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';

// Simple non-custom element implementation for better compatibility
export function setupEndpointsList() {
    const container = document.getElementById('endpoints-list');
    if (!container) return;
    
    // Initial render
    renderEndpointsList(container);
    
    // Subscribe to state changes
    state.subscribe('endpoints', () => renderEndpointsList(container));
    
    // Set up event delegation
    container.addEventListener('click', async (e) => {
        // Find the closest endpoint item
        const item = e.target.closest('.endpoint-item');
        if (!item) return;
        
        const url = item.dataset.url;
        
        try {
            // Handle check button
            if (e.target.matches('.check-endpoint')) {
                await checkEndpoint(url, item);
            }
            // Handle remove button
            else if (e.target.matches('.remove-endpoint')) {
                if (confirm('Are you sure you want to remove this endpoint?')) {
                    removeEndpoint(url);
                    // Show temporary notification
                    showNotification('Endpoint removed', 'info');
                }
            }
            // Handle edit button
            else if (e.target.matches('.edit-endpoint')) {
                toggleEditMode(item);
            }
            // Handle save button
            else if (e.target.matches('.save-endpoint')) {
                saveEndpointChanges(item);
            }
        } catch (error) {
            ErrorHandler.handle(error);
            showNotification('Operation failed: ' + error.message, 'error');
        }
    });
}

function renderEndpointsList(container) {
    const endpoints = state.get('endpoints') || [];
    
    if (endpoints.length === 0) {
        container.innerHTML = '<p>No endpoints configured yet.</p>';
        return;
    }
    
    container.innerHTML = endpoints.map(endpoint => `
        <div class="endpoint-item" data-url="${endpoint.url}">
            <div class="endpoint-info">
                <div class="endpoint-header">
                    <div class="endpoint-status ${endpoint.status || 'unknown'}"></div>
                    <div class="endpoint-details">
                        <span class="endpoint-label">${endpoint.label}</span>
                        <span class="endpoint-type">(${endpoint.type})</span>
                    </div>
                </div>
                <div class="endpoint-url">${endpoint.url}</div>
                <div class="endpoint-edit-form" style="display: none;">
                    <div class="form-field">
                        <label for="edit-label-${encodeURIComponent(endpoint.url)}">Label</label>
                        <input type="text" class="edit-label" id="edit-label-${encodeURIComponent(endpoint.url)}" value="${endpoint.label}">
                    </div>
                    <div class="form-field">
                        <label for="edit-type-${encodeURIComponent(endpoint.url)}">Type</label>
                        <select class="edit-type" id="edit-type-${encodeURIComponent(endpoint.url)}">
                            <option value="query" ${endpoint.type === 'query' ? 'selected' : ''}>Query</option>
                            <option value="update" ${endpoint.type === 'update' ? 'selected' : ''}>Update</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="endpoint-actions">
                <button class="check-endpoint">Check</button>
                <button class="edit-endpoint">Edit</button>
                <button class="save-endpoint" style="display: none;">Save</button>
                <button class="remove-endpoint">Remove</button>
            </div>
        </div>
    `).join('');
}

async function checkEndpoint(url, item) {
    const statusIndicator = item.querySelector('.endpoint-status');
    
    // Set checking status
    statusIndicator.className = 'endpoint-status checking';
    
    try {
        // Import endpointManager here to avoid circular dependencies
        const { EndpointManager } = await import('../../services/sparql/endpoints.js');
        const endpointManager = new EndpointManager();
        
        // Find the endpoint in the state
        const endpoints = state.get('endpoints');
        const endpoint = endpoints.find(e => e.url === url);
        
        if (!endpoint) {
            throw new Error('Endpoint not found');
        }
        
        // Check the endpoint
        const status = await endpointManager.checkEndpoint(url, endpoint.credentials);
        
        // Update the endpoint status
        endpointManager.updateEndpoint(url, { 
            status: status ? 'active' : 'inactive',
            lastChecked: new Date().toISOString()
        });
        
        // Show notification
        showNotification(
            `Endpoint is ${status ? 'active' : 'inactive'}`, 
            status ? 'success' : 'error'
        );
    } catch (error) {
        console.error('Error checking endpoint:', error);
        statusIndicator.className = 'endpoint-status error';
        throw error;
    }
}

function removeEndpoint(url) {
    // Import endpointManager here to avoid circular dependencies
    import('../../services/sparql/endpoints.js').then(({ EndpointManager }) => {
        const endpointManager = new EndpointManager();
        endpointManager.removeEndpoint(url);
    });
}

function toggleEditMode(item) {
    const editForm = item.querySelector('.endpoint-edit-form');
    const saveButton = item.querySelector('.save-endpoint');
    const editButton = item.querySelector('.edit-endpoint');
    
    if (editForm.style.display === 'none') {
        // Show edit form
        editForm.style.display = 'block';
        saveButton.style.display = 'inline-block';
        editButton.style.display = 'none';
    } else {
        // Hide edit form
        editForm.style.display = 'none';
        saveButton.style.display = 'none';
        editButton.style.display = 'inline-block';
    }
}

function saveEndpointChanges(item) {
    const url = item.dataset.url;
    const label = item.querySelector('.edit-label').value;
    const type = item.querySelector('.edit-type').value;
    
    // Import endpointManager here to avoid circular dependencies
    import('../../services/sparql/endpoints.js').then(({ EndpointManager }) => {
        const endpointManager = new EndpointManager();
        endpointManager.updateEndpoint(url, { label, type });
        
        // Hide edit form
        toggleEditMode(item);
        
        // Show notification
        showNotification('Endpoint updated successfully', 'success');
    });
}

// Make this available globally for other components to use
window.updateEndpointsList = function() {
    const container = document.getElementById('endpoints-list');
    if (container) {
        renderEndpointsList(container);
    }
};

function showNotification(message, type = 'info') {
    // Use global notification function if available
    if (typeof window.showNotification === 'function') {
        window.showNotification(message, type);
        return;
    }
    
    // Fallback to console
    console.log(`${type.toUpperCase()}: ${message}`);
}

================
File: src/js/ui/components/forms.js
================
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';
import { rdfModel } from '../../services/rdf/rdf-model.js';
import { extractMetadataFromUrl, createDatasetFromMetadata } from '../../services/rdf/rdf-extractor.js';
import { showNotification } from './notifications.js';

export function setupForms() {
  setupPostForm();
  setupEndpointForm();
}

function setupPostForm() {
  console.log('Setting up post form...');
  const form = document.getElementById('post-form');
  if (!form) {
    console.warn('Post form not found, it may be loaded dynamically');
    return;
  }
  
  console.log('Post form found, setting up extract button...');
  
  // Set up the extract button
  const extractButton = document.getElementById('extract-metadata');
  const urlInput = document.getElementById('url');
  
  if (extractButton && urlInput) {
    console.log('Extract button found, adding listener');
    extractButton.addEventListener('click', async () => {
      if (urlInput.value) {
        try {
          extractButton.disabled = true;
          extractButton.textContent = 'Extracting...';
          
          showNotification('Extracting metadata, please wait...', 'info');
          
          const metadata = await extractMetadataFromUrl(urlInput.value);
          
          // Fill in form fields with extracted metadata
          if (metadata.title) {
            const titleInput = document.getElementById('title');
            if (titleInput && !titleInput.value) {
              titleInput.value = metadata.title;
            }
          }
          
          if (metadata.description) {
            const contentInput = document.getElementById('content');
            if (contentInput && !contentInput.value) {
              contentInput.value = metadata.description;
            }
          }
          
          if (metadata.tags && metadata.tags.length > 0) {
            const tagsInput = document.getElementById('tags');
            if (tagsInput && !tagsInput.value) {
              tagsInput.value = metadata.tags.join(', ');
            }
          }
          
          // Update preview
          const previewElement = document.getElementById('post-preview');
          if (previewElement) {
            previewElement.innerHTML = `
              <h3>Link Preview</h3>
              <div class="link-preview">
                <div class="preview-card">
                  ${metadata.image ? `<div class="preview-image"><img src="${metadata.image}" alt="${metadata.title || 'Preview'}"></div>` : ''}
                  <div class="preview-content">
                    <h3 class="preview-title">${metadata.title || 'No title'}</h3>
                    <p class="preview-description">${metadata.description || ''}</p>
                    ${metadata.siteName ? `<span class="preview-site">${metadata.siteName}</span>` : ''}
                  </div>
                </div>
              </div>
            `;
          }
          
          showNotification('Metadata extracted successfully', 'success');
          
        } catch (error) {
          console.error('Error extracting metadata:', error);
          showNotification(`Failed to extract metadata: ${error.message}`, 'error');
        } finally {
          extractButton.disabled = false;
          extractButton.textContent = 'Extract';
        }
      } else {
        showNotification('Please enter a valid URL first', 'warning');
      }
    });
  } else {
    console.warn('Extract button or URL input not found!');
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    try {
      state.update('postSubmitting', true);
      const formData = new FormData(form);
      
      // Extract form data
      const postData = {
        type: formData.get('post-type'),
        content: formData.get('content'),
        tags: formData.get('tags') ? formData.get('tags').split(',').map(tag => tag.trim()) : []
      };
      
      // If it's a link post, extract the URL
      if (postData.type === 'link' && formData.get('url')) {
        postData.url = formData.get('url');
      }
      
      // If title is provided, add it
      if (formData.get('title')) {
        postData.title = formData.get('title');
      }
      
      // Create post in the RDF model
      const postId = rdfModel.createPost(postData);
      
      // Try to sync with endpoint, but continue even if it fails
      try {
        await rdfModel.syncWithEndpoint();
      } catch (syncError) {
        console.warn('Post created locally but failed to sync with endpoint', syncError);
      }
      
      // Update UI state
      state.update('lastPost', {
        id: postId,
        ...postData,
        timestamp: new Date().toISOString()
      });
      
      state.update('lastPostStatus', 'success');
      
      // Reset form
      form.reset();
      
      // Show success notification
      showNotification('Post created successfully', 'success');
      
    } catch (error) {
      ErrorHandler.handle(error);
      state.update('lastPostStatus', 'error');
      showNotification('Failed to create post: ' + error.message, 'error');
    } finally {
      state.update('postSubmitting', false);
    }
  });
}

// Listen for post type changes 
const typeSelector = document.getElementById('post-type');
if (typeSelector) {
  typeSelector.addEventListener('change', (e) => {
    console.log('Post type changed to:', e.target.value);
    // In a real implementation, we would toggle between different form types
    alert('Changing post type is not implemented in this demo. Please refresh the page.');
  });
}

function setupEndpointForm() {
  const form = document.getElementById('endpoint-form');
  if (!form) return;
  
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    try {
      const url = document.getElementById('endpoint-url').value;
      const label = document.getElementById('endpoint-label').value;
      const type = 'query'; // Default to query, can be extended with dropdown
      
      // Import required here to avoid circular dependencies
      const { EndpointManager } = await import('../../services/sparql/endpoints.js');
      const endpointManager = new EndpointManager();
      
      endpointManager.addEndpoint(url, label, type);
      form.reset();
      
      showNotification('Endpoint added successfully', 'success');
      
      // Refresh the endpoint list if the component exists
      if (typeof updateEndpointsList === 'function') {
        updateEndpointsList();
      }
    } catch (error) {
      ErrorHandler.handle(error);
      showNotification('Failed to add endpoint: ' + error.message, 'error');
    }
  });
}

function addFormField(container, field) {
  const wrapper = document.createElement('div');
  wrapper.className = 'form-field';
  
  // Create label
  const label = document.createElement('label');
  label.setAttribute('for', field.name);
  label.textContent = field.label;
  wrapper.appendChild(label);
  
  // Create input
  let input;
  if (field.type === 'textarea') {
    input = document.createElement('textarea');
  } else {
    input = document.createElement('input');
    input.type = field.type;
  }
  
  input.name = field.name;
  input.id = field.name;
  
  if (field.placeholder) {
    input.placeholder = field.placeholder;
  }
  
  if (field.required) {
    input.required = true;
  }
  
  wrapper.appendChild(input);
  container.appendChild(wrapper);
}

// REMOVED: Duplicate showNotification function was here
// Using the imported showNotification from notifications.js instead

================
File: src/js/ui/components/notifications.js
================
/**
 * Notifications system for the application
 */

let notificationsContainer;

/**
 * Initialize the notifications system
 */
export function initializeNotifications() {
    console.log('Initializing notifications system');
    
    // Create container if it doesn't exist
    if (!notificationsContainer) {
        notificationsContainer = document.createElement('div');
        notificationsContainer.className = 'notifications-container';
        document.body.appendChild(notificationsContainer);
        
        // Add styles if not already in the document
        if (!document.getElementById('notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
                .notifications-container {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 1000;
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    max-width: 300px;
                }
                
                .notification {
                    padding: 10px 15px;
                    border-radius: 4px;
                    color: white;
                    animation: notification-slide-in 0.3s ease-out;
                    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
                    position: relative;
                    overflow: hidden;
                }
                
                .notification::before {
                    content: '';
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    height: 3px;
                    background: rgba(255, 255, 255, 0.5);
                    animation: notification-timer 5s linear forwards;
                }
                
                .notification.success {
                    background-color: var(--success-color, #48bb78);
                }
                
                .notification.error {
                    background-color: var(--error-color, #f56565);
                }
                
                .notification.info {
                    background-color: var(--primary-color, #4299e1);
                }
                
                .notification.warning {
                    background-color: #ed8936;
                }
                
                .notification.fade-out {
                    opacity: 0;
                    transform: translateX(100%);
                    transition: opacity 0.3s, transform 0.3s;
                }
                
                @keyframes notification-slide-in {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                @keyframes notification-timer {
                    from {
                        width: 100%;
                    }
                    to {
                        width: 0%;
                    }
                }
            `;
            document.head.appendChild(style);
        }
    }
    
    // Make showNotification globally available
    window.showNotification = showNotification;
}

/**
 * Show a notification message
 * @param {string} message - The message to display
 * @param {string} type - The type of notification (success, error, info, warning)
 * @param {number} duration - How long to show the notification in ms
 */
export function showNotification(message, type = 'info', duration = 5000) {
    // Create the notification container if it doesn't exist
    if (!notificationsContainer) {
        initializeNotifications();
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    // Add to container
    notificationsContainer.appendChild(notification);
    
    // Set up removal after duration
    setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 300);
    }, duration);
    
    return notification;
}

/**
 * Show an error notification
 * @param {string} message - The error message
 * @param {number} duration - How long to show the notification in ms
 */
export function showError(message, duration = 5000) {
    return showNotification(message, 'error', duration);
}

/**
 * Show a success notification
 * @param {string} message - The success message
 * @param {number} duration - How long to show the notification in ms
 */
export function showSuccess(message, duration = 5000) {
    return showNotification(message, 'success', duration);
}

/**
 * Show an info notification
 * @param {string} message - The info message
 * @param {number} duration - How long to show the notification in ms
 */
export function showInfo(message, duration = 5000) {
    return showNotification(message, 'info', duration);
}

/**
 * Show a warning notification
 * @param {string} message - The warning message
 * @param {number} duration - How long to show the notification in ms
 */
export function showWarning(message, duration = 5000) {
    return showNotification(message, 'warning', duration);
}

================
File: src/js/ui/views/settings.js
================
import { state } from '../../core/state.js';
import { setupEndpointsList } from '../components/endpoints-list.js';
import { showNotification, initializeNotifications } from '../components/notifications.js';
import { rdfModel } from '../../services/rdf/rdf-model.js';

/**
 * Initialize the settings view
 */
export function initializeSettingsView() {
    const view = document.getElementById('settings-view');
    if (!view) {
        console.warn('Settings view not found');
        return;
    }
    
    // Setup components
    setupEndpointsList();
    initializeNotifications();
    
    // Setup theme selector if it exists
    setupThemeSelector();
    
    // Setup storage management
    setupStorageManagement();
}

/**
 * Setup theme selector component
 */
function setupThemeSelector() {
    const themeSelector = document.getElementById('theme-selector');
    if (!themeSelector) return;
    
    // Get current theme from localStorage or use default
    const currentTheme = localStorage.getItem('squirt_theme') || 'light';
    
    // Set initial value
    themeSelector.value = currentTheme;
    
    // Apply theme to document
    document.documentElement.setAttribute('data-theme', currentTheme);
    
    // Listen for changes
    themeSelector.addEventListener('change', () => {
        const theme = themeSelector.value;
        localStorage.setItem('squirt_theme', theme);
        document.documentElement.setAttribute('data-theme', theme);
        showNotification(`Theme changed to ${theme}`, 'info');
    });
}

/**
 * Setup storage management section
 */
function setupStorageManagement() {
    const storageSection = document.querySelector('.storage-section');
    if (!storageSection) return;
    
    // Create export button if it doesn't exist
    if (!document.getElementById('export-data')) {
        const exportBtn = document.createElement('button');
        exportBtn.id = 'export-data';
        exportBtn.textContent = 'Export Data';
        exportBtn.addEventListener('click', exportData);
        storageSection.appendChild(exportBtn);
    }
    
    // Create import button if it doesn't exist
    if (!document.getElementById('import-data')) {
        const importBtn = document.createElement('button');
        importBtn.id = 'import-data';
        importBtn.textContent = 'Import Data';
        importBtn.addEventListener('click', () => {
            // Create a hidden file input
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.ttl,.json';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);
            
            // Listen for file selection
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    importData(file);
                }
                document.body.removeChild(fileInput);
            });
            
            // Trigger file dialog
            fileInput.click();
        });
        storageSection.appendChild(importBtn);
    }
    
    // Create clear data button if it doesn't exist
    if (!document.getElementById('clear-data')) {
        const clearBtn = document.createElement('button');
        clearBtn.id = 'clear-data';
        clearBtn.className = 'danger';
        clearBtn.textContent = 'Clear All Data';
        clearBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                clearAllData();
            }
        });
        storageSection.appendChild(clearBtn);
    }
    
    // Add storage usage info
    updateStorageUsage();
}

/**
 * Export all application data
 */
async function exportData() {
    try {
        // Get RDF dataset
        const dataset = state.get('rdfDataset');
        
        if (!dataset || dataset.size === 0) {
            showNotification('No data to export', 'warning');
            return;
        }
        
        // Convert to Turtle format
        const turtle = dataset.toString();
        
        // Create a download link
        const blob = new Blob([turtle], { type: 'text/turtle' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const date = new Date().toISOString().split('T')[0];
        a.href = url;
        a.download = `squirt_export_${date}.ttl`;
        a.style.display = 'none';
        
        // Trigger download
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        showNotification('Data exported successfully', 'success');
    } catch (error) {
        console.error('Error exporting data:', error);
        showNotification('Failed to export data', 'error');
    }
}

/**
 * Import data from file
 * @param {File} file - The file to import
 */
async function importData(file) {
    try {
        const reader = new FileReader();
        
        reader.onload = async (e) => {
            try {
                const content = e.target.result;
                
                // Try to parse as Turtle
                try {
                    const dataset = await rdfModel.parseFromString(content);
                    
                    // Merge with existing dataset
                    const currentDataset = state.get('rdfDataset');
                    dataset.forEach(quad => {
                        currentDataset.add(quad);
                    });
                    
                    // Update state
                    state.update('rdfDataset', currentDataset);
                    
                    // Save to cache
                    rdfModel.saveToCache(currentDataset);
                    
                    showNotification('Data imported successfully', 'success');
                } catch (parseError) {
                    console.error('Error parsing imported data:', parseError);
                    showNotification('Invalid data format', 'error');
                }
            } catch (processError) {
                console.error('Error processing imported data:', processError);
                showNotification('Failed to import data', 'error');
            }
        };
        
        reader.onerror = () => {
            showNotification('Failed to read file', 'error');
        };
        
        reader.readAsText(file);
    } catch (error) {
        console.error('Error importing data:', error);
        showNotification('Failed to import data', 'error');
    }
}

/**
 * Clear all application data
 */
function clearAllData() {
    try {
        // Clear RDF dataset
        state.update('rdfDataset', rdfModel.createEmptyDataset());
        
        // Clear localStorage except for settings
        const themeSettings = localStorage.getItem('squirt_theme');
        const endpointSettings = localStorage.getItem('squirt_endpoints');
        
        localStorage.clear();
        
        // Restore settings
        if (themeSettings) {
            localStorage.setItem('squirt_theme', themeSettings);
        }
        
        if (endpointSettings) {
            localStorage.setItem('squirt_endpoints', endpointSettings);
        }
        
        showNotification('All data has been cleared', 'success');
        
        // Update storage usage display
        updateStorageUsage();
    } catch (error) {
        console.error('Error clearing data:', error);
        showNotification('Failed to clear data', 'error');
    }
}

/**
 * Update the storage usage display
 */
function updateStorageUsage() {
    // Create or get storage usage element
    let usageElement = document.getElementById('storage-usage');
    if (!usageElement) {
        usageElement = document.createElement('div');
        usageElement.id = 'storage-usage';
        document.querySelector('.storage-section')?.appendChild(usageElement);
    }
    
    // Calculate localStorage usage
    let total = 0;
    for (const key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
            total += localStorage[key].length * 2; // Approximate size in bytes
        }
    }
    
    // Format size
    let size;
    if (total < 1024) {
        size = `${total} bytes`;
    } else if (total < 1024 * 1024) {
        size = `${(total / 1024).toFixed(2)} KB`;
    } else {
        size = `${(total / (1024 * 1024)).toFixed(2)} MB`;
    }
    
    // Update display
    usageElement.textContent = `Storage used: ${size}`;
}

================
File: src/js/ui/views/wiki-editor.js
================
/**
 * Wiki Editor component using CodeMirror
 */
import CodeMirror from 'codemirror';
import 'codemirror/lib/codemirror.css';
import 'codemirror/mode/markdown/markdown';
import 'codemirror/theme/monokai.css';
import 'codemirror/addon/edit/continuelist';
import 'codemirror/addon/display/placeholder';
import { marked } from 'marked';
import { rdfModel } from '../../services/rdf/rdf-model.js';
import { showNotification } from '../components/notifications.js';

let editor = null;
let preview = null;

/**
 * Initialize the Wiki editor component
 */
export function initializeWikiEditor() {
  const wikiContent = document.getElementById('wiki-content');
  const previewContainer = document.querySelector('.wiki-preview');
  const saveButton = document.getElementById('save-wiki');
  
  if (!wikiContent) {
    console.warn('Wiki content element not found');
    return;
  }
  
  // Create preview container if it doesn't exist
  if (!previewContainer) {
    preview = document.createElement('div');
    preview.className = 'wiki-preview';
    preview.innerHTML = '<h3>Preview</h3><div class="preview-content"></div>';
    
    const wikiEditor = document.querySelector('.wiki-editor');
    if (wikiEditor) {
      wikiEditor.appendChild(preview);
    }
  } else {
    preview = previewContainer;
  }
  
  // Initialize CodeMirror editor
  editor = CodeMirror.fromTextArea(wikiContent, {
    mode: 'markdown',
    theme: 'monokai',
    lineNumbers: true,
    lineWrapping: true,
    viewportMargin: Infinity,
    placeholder: 'Enter markdown content here...',
    extraKeys: {
      'Enter': 'newlineAndIndentContinueMarkdownList'
    }
  });
  
  // Add change event listener for live preview
  editor.on('change', updatePreview);
  
  // Add event listener for save button
  if (saveButton) {
    saveButton.addEventListener('click', saveWikiEntry);
  }
  
  // Add custom toolbar
  addToolbar();
  
  // Initial preview update
  updatePreview();
}

/**
 * Update the preview with the current content
 */
function updatePreview() {
  const content = editor.getValue();
  const previewContent = preview.querySelector('.preview-content');
  
  if (previewContent) {
    // Render Markdown to HTML using marked
    previewContent.innerHTML = marked(content);
    
    // Syntax highlighting for code blocks
    previewContent.querySelectorAll('pre code').forEach(block => {
      if (window.hljs) {
        window.hljs.highlightBlock(block);
      }
    });
  }
}

/**
 * Add a toolbar with common markdown formatting buttons
 */
function addToolbar() {
  const toolbar = document.createElement('div');
  toolbar.className = 'editor-toolbar';
  
  // Define toolbar buttons
  const buttons = [
    { icon: 'format_bold', title: 'Bold', action: () => wrapText('**', '**') },
    { icon: 'format_italic', title: 'Italic', action: () => wrapText('*', '*') },
    { icon: 'format_quote', title: 'Quote', action: () => prependLine('> ') },
    { icon: 'format_list_bulleted', title: 'Bullet List', action: () => prependLine('- ') },
    { icon: 'format_list_numbered', title: 'Numbered List', action: () => prependLine('1. ') },
    { icon: 'insert_link', title: 'Link', action: insertLink },
    { icon: 'insert_photo', title: 'Image', action: insertImage },
    { icon: 'code', title: 'Code', action: () => wrapText('`', '`') },
    { icon: 'view_headline', title: 'Heading', action: () => prependLine('## ') }
  ];
  
  // Add Material Icons stylesheet if not already present
  if (!document.querySelector('link[href*="material-icons"]')) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://fonts.googleapis.com/icon?family=Material+Icons';
    document.head.appendChild(link);
  }
  
  // Create buttons
  buttons.forEach(button => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'toolbar-button';
    btn.title = button.title;
    btn.innerHTML = `<i class="material-icons">${button.icon}</i>`;
    btn.addEventListener('click', button.action);
    toolbar.appendChild(btn);
  });
  
  // Add toolbar before the editor
  const editorContainer = editor.getWrapperElement().parentNode;
  editorContainer.insertBefore(toolbar, editor.getWrapperElement());
  
  // Add toolbar styles
  if (!document.getElementById('editor-toolbar-styles')) {
    const style = document.createElement('style');
    style.id = 'editor-toolbar-styles';
    style.textContent = `
      .editor-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-bottom: 10px;
        padding: 5px;
        background: #f5f5f5;
        border-radius: 4px;
      }
      
      .toolbar-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        padding: 0;
        border: none;
        background: transparent;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .toolbar-button:hover {
        background: #e0e0e0;
      }
      
      .toolbar-button i {
        font-size: 20px;
        color: #555;
      }
      
      .wiki-preview {
        margin-top: 20px;
        padding: 20px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
      }
      
      .preview-content {
        font-family: system-ui, -apple-system, sans-serif;
        line-height: 1.6;
      }
      
      .preview-content h1, 
      .preview-content h2, 
      .preview-content h3 {
        margin-top: 1.5em;
        margin-bottom: 0.5em;
      }
      
      .preview-content p {
        margin-bottom: 1em;
      }
      
      .preview-content ul, 
      .preview-content ol {
        padding-left: 2em;
        margin-bottom: 1em;
      }
      
      .preview-content blockquote {
        border-left: 3px solid #ddd;
        margin-left: 0;
        padding-left: 1em;
        color: #777;
      }
      
      .preview-content code {
        font-family: monospace;
        background: #f0f0f0;
        padding: 2px 4px;
        border-radius: 3px;
      }
      
      .preview-content pre {
        background: #f0f0f0;
        padding: 1em;
        border-radius: 4px;
        overflow-x: auto;
      }
      
      .preview-content img {
        max-width: 100%;
      }
    `;
    document.head.appendChild(style);
  }
}

/**
 * Wrap selected text with prefix and suffix
 */
function wrapText(prefix, suffix) {
  const selection = editor.getSelection();
  if (selection) {
    editor.replaceSelection(prefix + selection + suffix);
  } else {
    const cursor = editor.getCursor();
    editor.replaceRange(prefix + suffix, cursor);
    editor.setCursor({
      line: cursor.line,
      ch: cursor.ch + prefix.length
    });
  }
  editor.focus();
}

/**
 * Prepend each line in selection with text
 */
function prependLine(text) {
  const selection = editor.getSelection();
  const cursor = editor.getCursor();
  
  if (selection) {
    const lines = selection.split('\n');
    const newText = lines.map(line => text + line).join('\n');
    editor.replaceSelection(newText);
  } else {
    const line = editor.getLine(cursor.line);
    editor.replaceRange(text + line, { line: cursor.line, ch: 0 }, { line: cursor.line, ch: line.length });
    editor.setCursor({ line: cursor.line, ch: text.length + cursor.ch });
  }
  editor.focus();
}

/**
 * Insert a link at cursor position
 */
function insertLink() {
  const selection = editor.getSelection();
  const url = prompt('Enter URL:', 'https://');
  
  if (url) {
    if (selection) {
      editor.replaceSelection(`[${selection}](${url})`);
    } else {
      const text = prompt('Enter link text:', 'Link text');
      if (text) {
        editor.replaceSelection(`[${text}](${url})`);
      }
    }
  }
  editor.focus();
}

/**
 * Insert an image at cursor position
 */
function insertImage() {
  const url = prompt('Enter image URL:', 'https://');
  
  if (url) {
    const alt = prompt('Enter image description:', 'Image');
    if (alt) {
      editor.replaceSelection(`![${alt}](${url})`);
    }
  }
  editor.focus();
}

/**
 * Save the current wiki entry
 */
function saveWikiEntry() {
  const titleInput = document.getElementById('wiki-title');
  const tagsInput = document.getElementById('wiki-tags');
  
  if (!titleInput || !titleInput.value.trim()) {
    showNotification('Please enter a title for your wiki entry', 'error');
    return;
  }
  
  const content = editor.getValue();
  if (!content.trim()) {
    showNotification('Please enter some content for your wiki entry', 'error');
    return;
  }
  
  const tags = tagsInput && tagsInput.value 
    ? tagsInput.value.split(',').map(tag => tag.trim())
    : [];
  
  try {
    // Create wiki post in RDF model
    const postId = rdfModel.createPost({
      type: 'wiki',
      title: titleInput.value.trim(),
      content: content,
      tags: tags
    });
    
    // Try to sync with endpoint
    rdfModel.syncWithEndpoint()
      .catch(error => {
        console.warn('Wiki entry saved locally but failed to sync with endpoint', error);
      });
    
    // Reset form
    titleInput.value = '';
    editor.setValue('');
    if (tagsInput) tagsInput.value = '';
    
    showNotification('Wiki entry saved successfully', 'success');
    
    // Refresh wiki entries list
    loadWikiEntries();
  } catch (error) {
    console.error('Error saving wiki entry:', error);
    showNotification('Failed to save wiki entry: ' + error.message, 'error');
  }
}

/**
 * Load and display wiki entries
 */
function loadWikiEntries() {
  const entriesList = document.querySelector('.wiki-entries');
  if (!entriesList) return;
  
  // Clear existing entries
  entriesList.innerHTML = '<h3>Recent Entries</h3>';
  
  try {
    // Get wiki posts from RDF model
    const entries = rdfModel.getPosts({
      type: 'wiki',
      limit: 10 // Show only the 10 most recent entries
    });
    
    if (entries.length === 0) {
      entriesList.innerHTML += '<p>No wiki entries found.</p>';
      return;
    }
    
    // Create entries list
    const list = document.createElement('ul');
    list.className = 'entries-list';
    
    entries.forEach(entry => {
      const item = document.createElement('li');
      item.className = 'entry-item';
      
      item.innerHTML = `
        <h4 class="entry-title">${entry.title || 'Untitled'}</h4>
        <p class="entry-preview">${entry.content.substring(0, 100)}${entry.content.length > 100 ? '...' : ''}</p>
        <div class="entry-meta">
          <span class="entry-date">${new Date(entry.created).toLocaleString()}</span>
          ${entry.tags.length > 0 ? `<span class="entry-tags">${entry.tags.join(', ')}</span>` : ''}
        </div>
        <button class="view-entry" data-id="${entry.id}">View</button>
        <button class="edit-entry" data-id="${entry.id}">Edit</button>
      `;
      
      // Add click handlers for buttons
      item.querySelector('.view-entry').addEventListener('click', () => viewEntry(entry.id));
      item.querySelector('.edit-entry').addEventListener('click', () => editEntry(entry.id));
      
      list.appendChild(item);
    });
    
    entriesList.appendChild(list);
    
    // Add entries list styles
    if (!document.getElementById('entries-list-styles')) {
      const style = document.createElement('style');
      style.id = 'entries-list-styles';
      style.textContent = `
        .entries-list {
          list-style: none;
          padding: 0;
          margin: 0;
        }
        
        .entry-item {
          padding: 15px;
          margin-bottom: 15px;
          border: 1px solid #eee;
          border-radius: 4px;
          background: white;
        }
        
        .entry-title {
          margin: 0 0 10px 0;
          color: var(--primary-color, #3498db);
        }
        
        .entry-preview {
          margin: 0 0 10px 0;
          color: #666;
        }
        
        .entry-meta {
          display: flex;
          flex-wrap: wrap;
          gap: 10px;
          margin-bottom: 10px;
          font-size: 0.875rem;
          color: #999;
        }
        
        .entry-item button {
          padding: 5px 10px;
          margin-right: 5px;
          background: var(--primary-color, #3498db);
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
        
        .entry-item button:hover {
          opacity: 0.9;
        }
      `;
      document.head.appendChild(style);
    }
  } catch (error) {
    console.error('Error loading wiki entries:', error);
    entriesList.innerHTML += `<p class="error">Error loading entries: ${error.message}</p>`;
  }
}

/**
 * View a wiki entry in detail
 */
function viewEntry(id) {
  try {
    // Get wiki entries container
    const entriesContainer = document.querySelector('.wiki-entries');
    if (!entriesContainer) return;
    
    // Get post from RDF model
    const posts = rdfModel.getPosts();
    const post = posts.find(p => p.id === id);
    
    if (!post) {
      showNotification('Entry not found', 'error');
      return;
    }
    
    // Create entry view
    const entryView = document.createElement('div');
    entryView.className = 'entry-detail';
    
    entryView.innerHTML = `
      <div class="entry-toolbar">
        <button class="back-button">Back to list</button>
        <button class="edit-entry" data-id="${post.id}">Edit</button>
      </div>
      <h3 class="entry-title">${post.title || 'Untitled'}</h3>
      <div class="entry-meta">
        <span class="entry-date">${new Date(post.created).toLocaleString()}</span>
        ${post.tags.length > 0 ? `<span class="entry-tags">Tags: ${post.tags.join(', ')}</span>` : ''}
      </div>
      <div class="entry-content">${marked(post.content)}</div>
    `;
    
    // Replace entries list with entry view
    entriesContainer.innerHTML = '';
    entriesContainer.appendChild(entryView);
    
    // Add back button handler
    entryView.querySelector('.back-button').addEventListener('click', loadWikiEntries);
    
    // Add edit button handler
    entryView.querySelector('.edit-entry').addEventListener('click', () => editEntry(post.id));
    
    // Syntax highlighting for code blocks
    entryView.querySelectorAll('pre code').forEach(block => {
      if (window.hljs) {
        window.hljs.highlightBlock(block);
      }
    });
    
    // Add entry detail styles
    if (!document.getElementById('entry-detail-styles')) {
      const style = document.createElement('style');
      style.id = 'entry-detail-styles';
      style.textContent = `
        .entry-detail {
          padding: 20px;
          background: white;
          border-radius: 4px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .entry-toolbar {
          display: flex;
          gap: 10px;
          margin-bottom: 20px;
        }
        
        .entry-toolbar button {
          padding: 5px 10px;
          background: var(--primary-color, #3498db);
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
        
        .entry-detail .entry-title {
          margin: 0 0 10px 0;
          font-size: 2rem;
          color: var(--text-color, #2c3e50);
        }
        
        .entry-detail .entry-meta {
          display: flex;
          flex-wrap: wrap;
          gap: 15px;
          margin-bottom: 20px;
          color: #777;
        }
        
        .entry-detail .entry-content {
          line-height: 1.6;
          font-size: 1.1rem;
        }
        
        .entry-detail .entry-content h1,
        .entry-detail .entry-content h2,
        .entry-detail .entry-content h3 {
          margin-top: 1.5em;
          margin-bottom: 0.5em;
        }
        
        .entry-detail .entry-content p {
          margin-bottom: 1em;
        }
        
        .entry-detail .entry-content img {
          max-width: 100%;
        }
        
        .entry-detail .entry-content blockquote {
          border-left: 3px solid #ddd;
          margin-left: 0;
          padding-left: 1em;
          color: #777;
        }
      `;
      document.head.appendChild(style);
    }
  } catch (error) {
    console.error('Error viewing wiki entry:', error);
    showNotification('Error viewing entry: ' + error.message, 'error');
  }
}

/**
 * Edit an existing wiki entry
 */
function editEntry(id) {
  try {
    // Get post from RDF model
    const posts = rdfModel.getPosts();
    const post = posts.find(p => p.id === id);
    
    if (!post) {
      showNotification('Entry not found', 'error');
      return;
    }
    
    // Get form elements
    const titleInput = document.getElementById('wiki-title');
    const tagsInput = document.getElementById('wiki-tags');
    
    if (!titleInput) {
      showNotification('Editor not found', 'error');
      return;
    }
    
    // Populate form with post data
    titleInput.value = post.title || '';
    if (tagsInput) {
      tagsInput.value = post.tags.join(', ');
    }
    
    // Set editor content
    editor.setValue(post.content || '');
    
    // Scroll to editor
    document.querySelector('.wiki-editor').scrollIntoView({
      behavior: 'smooth',
      block: 'start'
    });
    
    // Update save button to handle updates
    const saveButton = document.getElementById('save-wiki');
    if (saveButton) {
      // Remove existing click listeners
      const newSaveButton = saveButton.cloneNode(true);
      saveButton.parentNode.replaceChild(newSaveButton, saveButton);
      
      // Add new click listener for updating
      newSaveButton.addEventListener('click', () => updateWikiEntry(id));
    }
    
    showNotification('Editing entry: ' + post.title, 'info');
  } catch (error) {
    console.error('Error editing wiki entry:', error);
    showNotification('Error editing entry: ' + error.message, 'error');
  }
}

/**
 * Update an existing wiki entry
 */
function updateWikiEntry(id) {
  const titleInput = document.getElementById('wiki-title');
  const tagsInput = document.getElementById('wiki-tags');
  
  if (!titleInput || !titleInput.value.trim()) {
    showNotification('Please enter a title for your wiki entry', 'error');
    return;
  }
  
  const content = editor.getValue();
  if (!content.trim()) {
    showNotification('Please enter some content for your wiki entry', 'error');
    return;
  }
  
  const tags = tagsInput && tagsInput.value 
    ? tagsInput.value.split(',').map(tag => tag.trim())
    : [];
  
  try {
    // First delete the existing post
    rdfModel.deletePost(id);
    
    // Then create a new post with the same ID (simulating an update)
    const postData = {
      type: 'wiki',
      title: titleInput.value.trim(),
      content: content,
      tags: tags
    };
    
    // Add custom ID field for the RDF model to use
    postData.customId = id;
    
    // Create updated wiki post
    rdfModel.createPost(postData);
    
    // Try to sync with endpoint
    rdfModel.syncWithEndpoint()
      .catch(error => {
        console.warn('Wiki entry updated locally but failed to sync with endpoint', error);
      });
    
    // Reset form
    titleInput.value = '';
    editor.setValue('');
    if (tagsInput) tagsInput.value = '';
    
    // Reset save button to handle new entries
    const saveButton = document.getElementById('save-wiki');
    if (saveButton) {
      // Remove existing click listeners
      const newSaveButton = saveButton.cloneNode(true);
      saveButton.parentNode.replaceChild(newSaveButton, saveButton);
      
      // Add new click listener for saving
      newSaveButton.addEventListener('click', saveWikiEntry);
    }
    
    showNotification('Wiki entry updated successfully', 'success');
    
    // Refresh wiki entries list
    loadWikiEntries();
  } catch (error) {
    console.error('Error updating wiki entry:', error);
    showNotification('Failed to update wiki entry: ' + error.message, 'error');
  }
}

// Initialize wiki editor when the view is shown
document.addEventListener('routeChange', (e) => {
  if (e.detail.to === 'wiki-view') {
    setTimeout(() => {
      initializeWikiEditor();
      loadWikiEntries();
    }, 100);
  }
});

================
File: src/js/utils/utils.js
================
export const namespaces = {
  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
  rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
  dc: 'http://purl.org/dc/terms/',
  foaf: 'http://xmlns.com/foaf/0.1/',
  squirt: 'http://purl.org/stuff/squirt/'
};

export function generateNid(content) {
  const date = new Date().toISOString().split('T')[0];
  const hash = hashContent(content);
  return `http://purl.org/stuff/squirt/nid_${date}_${hash}`;
}

function hashContent(content) {
  return Array.from(content)
    .reduce((hash, char) => {
      return ((hash << 5) - hash) + char.charCodeAt(0) | 0;
    }, 0)
    .toString(16)
    .slice(0, 4);
}

================
File: src/js/app.js
================
// Import dependencies with ES module syntax
import { setupForms } from './ui/components/forms.js';
import { initializeRouter } from './router.js';
import { EndpointManager } from './services/sparql/endpoints.js';
import { state } from './core/state.js';
import { ErrorHandler } from './core/errors.js';
import { rdfModel } from './services/rdf/rdf-model.js';
import { initializeNotifications } from './ui/components/notifications.js';
import { initializeSettingsView } from './ui/views/settings.js';

// Import wiki editor to ensure its event listeners are registered
import './ui/views/wiki-editor.js';

// Define application views
export const VIEWS = {
  POST: 'post-view',
  DEVELOPER: 'developer-view',
  WIKI: 'wiki-view',
  PROFILE: 'profile-view',
  SETTINGS: 'settings-view'
};

// Initialize the application when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
  try {
    await initializeApp();
  } catch (error) {
    ErrorHandler.handle(error);
  }
});

/**
 * Initialize the application
 */
async function initializeApp() {
  console.log('Initializing application...');
  
  try {
    // Set up the application structure
    setupViews();
    setupNavigation();
    setupHamburgerMenu();
    
    // Initialize notifications system
    initializeNotifications();
    
    // Initialize UI components
    setupForms();
    
    // Initialize view-specific components
    initializeSettingsView();
    
    // Initialize routing
    initializeRouter();
    
    // Initialize services
    const endpointManager = new EndpointManager();
    await endpointManager.initialize();
    
    // Register service worker for PWA support
    registerServiceWorker();
    
    // Check for share target (for mobile devices)
    checkForShareTarget();
    
    console.log('Application initialized successfully');
  } catch (error) {
    console.error('Error initializing application:', error);
    ErrorHandler.handle(error);
  }
}

/**
 * Set up application views
 */
function setupViews() {
  const main = document.querySelector('main');
  if (!main) {
    throw new Error('Main element not found');
  }

  // Create any missing view containers
  Object.values(VIEWS).forEach(viewId => {
    if (typeof viewId !== 'string' || !viewId.endsWith('-view')) {
      throw new Error(`Invalid view ID format: ${viewId}`);
    }

    if (!document.getElementById(viewId)) {
      const view = document.createElement('div');
      view.id = viewId;
      view.classList.add('view', 'hidden');
      main.appendChild(view);
    }
  });
  
  // Add wiki view content if it doesn't exist
  const wikiView = document.getElementById(VIEWS.WIKI);
  if (wikiView && wikiView.children.length === 0) {
    wikiView.innerHTML = `
      <h2>Wiki</h2>
      <div class="wiki-editor">
        <div class="form-field">
          <label for="wiki-title">Title</label>
          <input type="text" id="wiki-title" name="title" required>
        </div>
        <div class="form-field">
          <label for="wiki-content">Content (Markdown supported)</label>
          <textarea id="wiki-content" name="content" rows="10" required></textarea>
        </div>
        <div class="form-field">
          <label for="wiki-tags">Tags (comma separated)</label>
          <input type="text" id="wiki-tags" name="tags" placeholder="tag1, tag2, tag3">
        </div>
        <button type="button" id="save-wiki">Save</button>
      </div>
      <div class="wiki-entries"></div>
    `;
  }
  
  // Add profile view content if it doesn't exist
  const profileView = document.getElementById(VIEWS.PROFILE);
  if (profileView && profileView.children.length === 0) {
    profileView.innerHTML = `
      <h2>Profile</h2>
      <form id="profile-form" class="form-group">
        <div class="form-field">
          <label for="profile-name">Name</label>
          <input type="text" id="profile-name" name="name">
        </div>
        <div class="form-field">
          <label for="profile-email">Email</label>
          <input type="email" id="profile-email" name="email">
        </div>
        <div class="form-field">
          <label for="profile-bio">Bio</label>
          <textarea id="profile-bio" name="bio"></textarea>
        </div>
        <button type="submit">Save Profile</button>
      </form>
    `;
  }
  
  // Add storage section to settings view if it doesn't exist
  const settingsView = document.getElementById(VIEWS.SETTINGS);
  if (settingsView && !settingsView.querySelector('.storage-section')) {
    const storageSection = document.createElement('div');
    storageSection.className = 'settings-section storage-section';
    storageSection.innerHTML = `
      <h3>Storage</h3>
      <div id="storage-usage">Calculating storage usage...</div>
    `;
    settingsView.appendChild(storageSection);
  }
}

/**
 * Set up navigation links
 */
function setupNavigation() {
  document.querySelectorAll('nav a').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const viewId = e.target.getAttribute('data-view');
      if (viewId) {
        window.location.hash = viewId.replace('-view', '');
        
        // If we have a hamburger menu, close it when navigating
        const menu = document.querySelector('.hamburger-menu');
        if (menu && menu.classList.contains('active')) {
          menu.classList.remove('active');
          document.querySelector('nav').classList.remove('visible');
        }
      }
    });
  });
}

/**
 * Set up hamburger menu for mobile devices
 */
function setupHamburgerMenu() {
  // Check if hamburger button already exists
  if (document.querySelector('.hamburger-button')) return;
  
  // Create hamburger button
  const hamburgerButton = document.createElement('button');
  hamburgerButton.className = 'hamburger-button';
  hamburgerButton.setAttribute('aria-label', 'Menu');
  hamburgerButton.innerHTML = `
    <span></span>
    <span></span>
    <span></span>
  `;
  
  // Add button to header
  const header = document.querySelector('header');
  if (header) {
    // Add menu wrapper with class for styling
    const menuWrapper = document.createElement('div');
    menuWrapper.className = 'hamburger-menu';
    menuWrapper.appendChild(hamburgerButton);
    header.appendChild(menuWrapper);
    
    // Add toggle functionality
    hamburgerButton.addEventListener('click', () => {
      menuWrapper.classList.toggle('active');
      document.querySelector('nav').classList.toggle('visible');
    });
    
    // Add CSS if not already present
    if (!document.getElementById('hamburger-style')) {
      const style = document.createElement('style');
      style.id = 'hamburger-style';
      style.textContent = `
        .hamburger-menu {
          display: none;
        }
        
        /* Mobile styles */
        @media (max-width: 768px) {
          .hamburger-menu {
            display: block;
            position: relative;
            z-index: 100;
          }
          
          .hamburger-button {
            background: none;
            border: none;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 24px;
            padding: 0;
            width: 30px;
          }
          
          .hamburger-button span {
            background-color: var(--text-color);
            border-radius: 3px;
            display: block;
            height: 3px;
            transition: all 0.3s ease;
            width: 100%;
          }
          
          .hamburger-menu.active .hamburger-button span:nth-child(1) {
            transform: translateY(10px) rotate(45deg);
          }
          
          .hamburger-menu.active .hamburger-button span:nth-child(2) {
            opacity: 0;
          }
          
          .hamburger-menu.active .hamburger-button span:nth-child(3) {
            transform: translateY(-10px) rotate(-45deg);
          }
          
          nav {
            background: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: none;
            flex-direction: column;
            gap: 0;
            left: 0;
            position: absolute;
            top: 100%;
            width: 100%;
          }
          
          nav.visible {
            display: flex;
          }
          
          nav a {
            border-bottom: 1px solid #eee;
            padding: 1rem;
            text-align: center;
          }
        }
      `;
      document.head.appendChild(style);
    }
  }
}

/**
 * Register service worker for PWA support
 */
function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/service-worker.js')
        .then(registration => {
          console.log('Service Worker registered with scope:', registration.scope);
        })
        .catch(error => {
          console.error('Service Worker registration failed:', error);
        });
    });
  }
}

/**
 * Check if the app was launched from a share target
 */
function checkForShareTarget() {
  // Check if this is a PWA launch with share data
  if (window.launchQueue) {
    window.launchQueue.setConsumer(async params => {
      if (params.files && params.files.length) {
        // Handle shared files
        const file = params.files[0];
        // Depending on the file type, process accordingly
        if (file.type.includes('text')) {
          const text = await file.text();
          // Pre-fill the post form
          const contentField = document.getElementById('content-field');
          if (contentField) {
            contentField.value = text;
          }
        }
      } else if (params.data && params.data.url) {
        // Handle shared URL
        const form = document.getElementById('post-form');
        const typeSelector = form.querySelector('[name="post-type"]');
        if (typeSelector) {
          typeSelector.value = 'link';
          updateFormFields(form, 'link');
          
          const urlField = form.querySelector('[name="url"]');
          if (urlField) {
            urlField.value = params.data.url;
          }
          
          if (params.data.title) {
            const titleField = form.querySelector('[name="title"]');
            if (titleField) {
              titleField.value = params.data.title;
            }
          }
          
          if (params.data.text) {
            const contentField = form.querySelector('[name="content"]');
            if (contentField) {
              contentField.value = params.data.text;
            }
          }
        }
      }
      
      // Switch to post view
      window.location.hash = 'post';
    });
  }
  
  // Check URL parameters for shared content
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has('text') || urlParams.has('url') || urlParams.has('title')) {
    const form = document.getElementById('post-form');
    if (form) {
      // If there's a URL, use the link post type
      if (urlParams.has('url')) {
        const typeSelector = form.querySelector('[name="post-type"]');
        if (typeSelector) {
          typeSelector.value = 'link';
          // Make sure form fields are updated for link type
          if (typeof updateFormFields === 'function') {
            updateFormFields(form, 'link');
          }
          
          // Set the URL field
          setTimeout(() => {
            const urlField = form.querySelector('[name="url"]');
            if (urlField) {
              urlField.value = urlParams.get('url');
            }
          }, 100);
        }
      }
      
      // Set the title if provided
      if (urlParams.has('title')) {
        setTimeout(() => {
          const titleField = form.querySelector('[name="title"]');
          if (titleField) {
            titleField.value = urlParams.get('title');
          }
        }, 100);
      }
      
      // Set the content field if provided
      if (urlParams.has('text')) {
        setTimeout(() => {
          const contentField = form.querySelector('[name="content"]');
          if (contentField) {
            contentField.value = urlParams.get('text');
          }
        }, 100);
      }
      
      // Switch to post view
      window.location.hash = 'post';
    }
  }
}

================
File: src/js/router.js
================
import { state } from './core/state.js';
import { ErrorHandler } from './core/errors.js';
import { VIEWS } from './app.js';

/**
 * Initialize the router
 */
export function initializeRouter() {
    if (!VIEWS) {
        throw new Error('VIEWS constant not available');
    }

    /**
     * Valid routes derived from view IDs
     * @constant {string[]}
     */
    const VALID_ROUTES = Object.values(VIEWS).map(view => view.replace('-view', ''));

    window.addEventListener('hashchange', () => {
        handleRoute(window.location.hash, VALID_ROUTES);
    });

    handleRoute(window.location.hash, VALID_ROUTES);
}

/**
 * Handle route changes
 * @param {string} hash - URL hash including #
 * @param {string[]} validRoutes - List of valid routes
 */
function handleRoute(hash, validRoutes) {
    try {
        const route = hash.slice(1) || 'post';
        
        if (!validRoutes.includes(route)) {
            throw new Error(`Invalid route: ${route}`);
        }

        const viewId = `${route}-view`;
        const view = document.getElementById(viewId);
        
        if (!view) {
            throw new Error(`View not found: ${viewId}`);
        }

        const currentView = state.get('currentView');
        
        // Fire pre-route change event
        const event = new CustomEvent('routeChange', {
            detail: {
                from: currentView,
                to: viewId
            },
            cancelable: true
        });

        if (!document.dispatchEvent(event)) {
            // Route change was prevented
            if (currentView) {
                window.location.hash = currentView.replace('-view', '');
            }
            return;
        }

        state.update('previousView', currentView);
        state.update('currentView', viewId);

        Object.values(VIEWS).forEach(id => {
            const view = document.getElementById(id);
            if (view) {
                view.classList.add('hidden');
            }
        });
        
        view.classList.remove('hidden');

    } catch (error) {
        ErrorHandler.handle(error);
        if (hash !== '#post') {
            window.location.hash = '#post';
        }
    }
}

================
File: test/spec/about.md
================
npm test -- tests/unit/RunCommand.spec.js

================
File: test/spec/sparql.spec.js
================
import { postToSparql, querySparql, getEndpoint } from '../../src/js/services/sparql/sparql.js';
import { state } from '../../src/js/core/state.js';
import rdf from 'rdf-ext';

// Mock the fetch function
global.fetch = jest.fn();

describe('SPARQL Operations', () => {
  const testDataset = rdf.dataset();
  const testSubject = rdf.namedNode('http://example.org/test');
  const testPredicate = rdf.namedNode('http://example.org/name');
  const testObject = rdf.literal('Test Entry');

  // Setup mock endpoints in state
  beforeEach(() => {
    testDataset.add(rdf.quad(testSubject, testPredicate, testObject));
    
    // Set up mock endpoints in state
    state.update('endpoints', [
      {
        url: 'http://test-query-endpoint:3030/sparql',
        label: 'Test Query Endpoint',
        type: 'query',
        status: 'active'
      },
      {
        url: 'http://test-update-endpoint:3030/sparql',
        label: 'Test Update Endpoint',
        type: 'update',
        status: 'active'
      }
    ]);
    
    // Reset mock fetch
    global.fetch.mockReset();
  });

  it('should successfully post data to SPARQL endpoint', async () => {
    // Mock successful POST response
    global.fetch.mockResolvedValueOnce({
      ok: true,
      status: 200,
      text: async () => 'Success'
    });

    const result = await postToSparql(testDataset);
    expect(result).toBe(true);
    
    // Verify fetch was called correctly
    expect(fetch).toHaveBeenCalledTimes(1);
    expect(fetch.mock.calls[0][0]).toBe('http://test-update-endpoint:3030/sparql');
    expect(fetch.mock.calls[0][1].method).toBe('POST');
    expect(fetch.mock.calls[0][1].headers['Content-Type']).toBe('application/sparql-update');
  });

  it('should verify posted data with query', async () => {
    const query = `
      SELECT ?o
      WHERE {
        <http://example.org/test> <http://example.org/name> ?o .
      }
    `;

    // Mock successful query response
    global.fetch.mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        results: {
          bindings: [
            {
              o: { 
                type: 'literal',
                value: 'Test Entry' 
              }
            }
          ]
        }
      })
    });

    const result = await querySparql(query);
    expect(result.results.bindings.length).toBeGreaterThan(0);
    expect(result.results.bindings[0].o.value).toBe('Test Entry');
    
    // Verify fetch was called correctly
    expect(fetch).toHaveBeenCalledTimes(1);
    expect(fetch.mock.calls[0][0]).toBe('http://test-query-endpoint:3030/sparql');
    expect(fetch.mock.calls[0][1].method).toBe('POST');
    expect(fetch.mock.calls[0][1].headers['Content-Type']).toBe('application/sparql-query');
  });

  it('should handle SPARQL syntax errors gracefully', async () => {
    const badQuery = 'SELECT * WHERE { INVALID SYNTAX }';

    // Mock error response
    global.fetch.mockResolvedValueOnce({
      ok: false,
      status: 400,
      text: async () => 'Parse error: Invalid syntax at line 1'
    });

    try {
      await querySparql(badQuery);
      fail('Should throw error for invalid query');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toContain('SPARQL query failed: 400');
      expect(error.message).toContain('Parse error:');
    }
  });

  it('should handle network errors gracefully', async () => {
    global.fetch.mockRejectedValueOnce(new Error('Failed to fetch'));

    try {
      await querySparql('SELECT * WHERE { ?s ?p ?o }');
      fail('Should throw error for network failure');
    } catch (error) {
      expect(error).toBeDefined();
    }
  });

  it('should handle empty dataset gracefully', async () => {
    const emptyDataset = rdf.dataset();
    
    // Mock successful POST response
    global.fetch.mockResolvedValueOnce({
      ok: true,
      status: 200,
      text: async () => 'Success'
    });
    
    const result = await postToSparql(emptyDataset);
    expect(result).toBe(true);
    
    // Verify fetch was called with empty dataset
    expect(fetch).toHaveBeenCalledTimes(1);
  });
});

================
File: test/setup.js
================
// Setup file for Jest tests
global.fetch = jest.fn();

// Mock the window object for browser-like environment
Object.defineProperty(window, 'location', {
  value: {
    hash: ''
  },
  writable: true
});

// Silence console errors during tests
console.error = jest.fn();
console.warn = jest.fn();

================
File: .babelrc
================
{
  "presets": [
    ["@babel/preset-env", {
      "targets": {
        "node": "current"
      }
    }]
  ],
  "plugins": [
    "@babel/plugin-transform-modules-commonjs"
  ]
}

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: about.md
================
```sh
cd ~/github-danny/hyperdata/packages/farelo/squirt

npm run build
npm run dev

npm run rp

```

================
File: babel.config.json
================
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "browsers": [
            "last 2 chrome versions",
            "last 2 firefox versions",
            "last 2 safari versions"
          ]
        },
        "modules": false,
        "useBuiltIns": "usage",
        "corejs": 3
      }
    ]
  ]
}

================
File: endpoints.json
================
[
    {
        "name": "local query",
        "type": "query",
        "url": "http://localhost:4030/semem/query",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    },
    {
        "name": "local update",
        "type": "update",
        "url": "http://localhost:4030/semem/update",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    }
]

================
File: jasmine.json
================
{
    "spec_dir": "test",
    "spec_files": [
        "**/*[sS]pec.js"
    ],
    "helpers": [],
    "stopSpecOnExpectationFailure": true,
    "random": false
}

================
File: jest.config.js
================
/** @type {import('jest').Config} */
module.exports = {
  transform: {
    '^.+\\.(js|jsx)$': 'babel-jest'
  },
  testEnvironment: 'jsdom',
  moduleFileExtensions: ['js', 'json'],
  transformIgnorePatterns: ['/node_modules/(?!(@rdfjs|rdf-ext)/)'],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1'
  },
  testMatch: ['**/test/spec/**/*.spec.js'],
  setupFiles: ['./test/setup.js']
};

================
File: package.json
================
{
  "name": "squirt",
  "version": "0.1.0",
  "type": "commonjs",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack serve --mode development",
    "test": "jest",
    "test:jasmine": "jasmine --config=jasmine.json",
    "rp": "tree --gitignore  -I 'knowledge|prompts|reference' > tree.xml && repomix -c repomix.config.json ."
  },
  "dependencies": {
    "@rdfjs/data-model": "^2.0.1",
    "@rdfjs/namespace": "^2.0.0",
    "@rdfjs/parser-n3": "^2.0.1",
    "@triply/yasgui": "^4.2.28",
    "codemirror": "^5.65.19",
    "cors": "^2.8.5",
    "marked": "^4.3.0",
    "rdf-ext": "^2.5.0"
  },
  "devDependencies": {
    "@babel/core": "^7.26.0",
    "@babel/plugin-transform-modules-commonjs": "^7.26.3",
    "@babel/preset-env": "^7.26.0",
    "babel-jest": "^29.7.0",
    "babel-loader": "^9.2.1",
    "chai": "^4.3.10",
    "css-loader": "^6.8.1",
    "html-webpack-plugin": "^5.6.0",
    "jasmine": "^5.1.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "mini-css-extract-plugin": "^2.9.2",
    "style-loader": "^3.3.3",
    "webpack": "^5.89.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.1"
  }
}

================
File: requirements_2025-03-28.md
================
The goal is to create the app described below. There is already a basic skeleton in place.

Please read this, review the code under `src`, think deeply and create a plan of action.

# Squirt

Squirt is a Progressive Web App designed to make posting information to the Web easy across all devices.

It will maintain a local representation of immediate data, a remote SPARQL store will be used for long-term persistence.  

It is an updated, combined revision of the following :

* legacy/foolicious - a link poster
* legacy/gnam - a link poster, same
* legacy/foowiki - a wiki
* legacy/trellis - a tree-based organiser

there was an attempt to revise before, under

* legacy/sparql-diamonds - towards a lib for the SPARQL comms
* legacy/heditor - a start with

## Coding Environment

- Languages : HTML, CSS, vanilla JavaScript
- Dev tools : npm, WebPack, Jasmine, Chai, loglevel, nodejs using es modules

The legacy versions used lots of jquery with hogan for templating. The new version should replace jquery with modern vanilla js and nunjucks for templating. Internally data will use the RDF model, persisted as RDF-Ext datasets in JSON objects.

The text editor component should be based on CodeMirror. There was an attempt at this in `legacy/heditor`.

There needs to be support for markdown extensions, as in `legacy/heditor`. If necessary use the `marked` lib for text translations.

## Data Model

 Items to be posted will be given a unique node id generated from the date an a hash of the content fields, eg. `http://purl.org/stuff/squirt/nid_2024-12-03_a3C5`. See the files under `squirt/legacy/turtle-examples` for legacy use of RDF.

Provision should be made to support Named Graphs.

## Current Status

### Directory Structure

* /public: Contains the built/bundled files
* /src: Contains the source code
* /css: Stylesheet files
* /html: HTML templates
* /js: JavaScript source code

* /core: Core functionality (errors, state management)
* /services: Backend-like services, including RDF and SPARQL
* /ui: Frontend components and views
* /utils: Utility functions

## Protocols

In increasing order of priority, the following should be supported :

- SPARQL query & update (over HTTP)
- SPARQL protocol
- Direct HTTP GET, POST, PATCH

## UI

- The PWA should be built in such a way that mobile devices can use their system 'Share' functionality to eg. post a link directly from a browser.
- A "hamburger" icon will show at all times in the top-right corner, on clicking a context menu will be shown allowing navigation between windows
- It should be visually appealing, using vanilla JS, CSS & HTML, no frameworks

### Windows

1. Input Form (user)
2. Input Form (advanced, for developers, sparql tools for query & update)
3. Link post/Twitter-style client (user)
4. Wiki/blog post client
5. Chat-style client (user)
6. User Profile (mostly FOAF fields)
7. Settings

#### 1. HTML Form

A drop-down list allows the type of message to be decided. This will be taken from an internal RDF representation of the apps capabilities.
Initially three forms will be available :

## Deployment

Squirt is be available directly from our site, https://hyperdata.it/squirt as well as being packaged for Google Play and F-Droid. It is open source, MIT license.

SPARQL endpoint details can be found in `squirt/endpoint.json`

================
File: tree.xml
================
.
 about.md
 babel.config.json
 endpoints.json
 jasmine.json
 jest.config.js
 package.json
 package-lock.json
 public
  demo.html
  icons
   icon-192x192.png
   icon-512x512.png
  index.html
  main.5e2c985a614e3bf02320.css
  main.bundle.js
  main.bundle.js.LICENSE.txt
  manifest.json
  service-worker.js
 repomix.config.json
 requirements_2025-03-28.md
 squirt_repomix.md
 src
  css
   form-styles.css
   styles.css
  html
   index.html
  js
      app.js
      core
       errors.js
       state.js
      router.js
      services
       rdf
        rdf-extractor.js
        rdf-model.js
       sparql
           endpoints.js
           sparql.js
           test
               spec
                   sparql.spec.js
      ui
       components
        endpoints-list.js
        forms.js
        notifications.js
       views
           settings.js
           wiki-editor.js
      utils
          utils.js
 storage
 test
  setup.js
  spec
      about.md
      sparql.spec.js
 tree.xml
 webpack.config.js

20 directories, 42 files

================
File: webpack.config.js
================
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
    entry: {
        main: ['./src/js/app.js', './src/css/styles.css', './src/css/form-styles.css']
    },
    output: {
        path: path.resolve('public'),
        filename: '[name].bundle.js',
        clean: true
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            },
            {
                test: /\.css$/,
                use: [
                    MiniCssExtractPlugin.loader,
                    'css-loader'
                ]
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './src/html/index.html'
        }),
        new MiniCssExtractPlugin({
            filename: '[name].[contenthash].css'
        })
    ],
    resolve: {
        extensions: ['.js', '.json']
    },
    devServer: {
        static: {
            directory: path.join(process.cwd(), 'public')
        },
        compress: true,
        hot: true,
        port: 9002
    }
}



================================================================
End of Codebase
================================================================
