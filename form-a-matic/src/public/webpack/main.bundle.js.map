{"version":3,"file":"main.bundle.js","mappings":";;;;;;;AAAA,MAAM,4BAA4B;;ACAlC,MAAM,iCAA4B;;ACAR;AACc;;;AAGxC;AACA,oBAAoB,oCAAW;AAC/B,qCAAqC,sCAAa;;AAElD;AACA,0BAA0B,sCAAa;;AAEvC;AACA;AACA;AACA,qCAAqC,sCAAa;AAClD,4BAA4B,iCAAQ;AACpC;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,yBAAyB,oCAAW;AACpC,cAAc;AACd,yBAAyB,sCAAa;AACtC,cAAc;AACd,yBAAyB,sCAAa;AACtC;AACA,wBAAwB,iCAAQ;AAChC;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;;;AAGA;AACA,uBAAuB,iCAAQ;AAC/B;;AAEA;AACA,iCAAiC,wBAAwB;AACzD;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AC1HgD;;AAEhD;;AAEA,iBAAiB,OAAO,EAAE,kC","sources":["webpack://form-a-matic/external var \"rdf\"","webpack://form-a-matic/external var \"N3Writer\"","webpack://form-a-matic/./src/public/extractor.js","webpack://form-a-matic/./src/browser-entry.js"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = rdf;","const __WEBPACK_NAMESPACE_OBJECT__ = N3Writer;","import rdf from 'rdf-ext';\nimport N3Writer from '@rdfjs/parser-n3';\n\n\nfunction createRDFNodes(data, parentSubject = null) {\n    const dataset = rdf.dataset();\n    const subject = parentSubject || rdf.blankNode();\n\n    data.forEach(item => {\n        const predicate = rdf.namedNode(item.namespace + item.term);\n\n        if (item.entries) {\n            // Handle multiple nested entries\n            item.entries.forEach(entry => {\n                const entrySubject = rdf.blankNode();\n                dataset.add(rdf.quad(subject, predicate, entrySubject));\n                const nestedDataset = createRDFNodes(Object.values(entry), entrySubject);\n                dataset.addAll(nestedDataset);\n            });\n        } else {\n            let object;\n            if (item.type === 'LITERAL') {\n                object = rdf.literal(item.value);\n            } else if (item.type === 'URI') {\n                object = rdf.namedNode(item.value);\n            } else {\n                object = rdf.blankNode();\n            }\n            dataset.add(rdf.quad(subject, predicate, object));\n        }\n    });\n\n    return dataset;\n}\n\nfunction extractAllElementsData(form) {\n    const elements = form.querySelectorAll('input, textarea');\n    const data = Array.from(elements).map(extractElementData);\n\n    // Group nested properties\n    const groupedData = data.reduce((acc, item) => {\n        if (item.children) {\n            const parentIndex = acc.findIndex(d => d.term === item.term);\n            if (parentIndex !== -1) {\n                acc[parentIndex].children = item.children;\n            } else {\n                acc.push(item);\n            }\n        } else {\n            acc.push(item);\n        }\n        return acc;\n    }, []);\n\n    return groupedData;\n}\n\n/*\nfunction extractElementData(element) {\n    const data = {};\n    for (const attr of element.attributes) {\n        if (attr.name.startsWith('data-')) {\n            const key = attr.name.slice(5); // Remove 'data-' prefix\n            data[key] = attr.value;\n        }\n    }\n    data.value = element.value;\n    return data;\n}\n    */\n\nfunction extractElementData(element) {\n    const data = {};\n    for (const attr of element.attributes) {\n        if (attr.name.startsWith('data-')) {\n            const key = attr.name.slice(5); // Remove 'data-' prefix\n            try {\n                // Try to parse as JSON for nested structures\n                data[key] = JSON.parse(attr.value);\n            } catch {\n                // If not JSON, store as is\n                data[key] = attr.value;\n            }\n        }\n    }\n    data.value = element.value;\n    if (element.tagName === 'FIELDSET') {\n        data.entries = Array.from(element.querySelectorAll('.nested-entry'))\n            .map(entry => {\n                const entryData = {};\n                entry.querySelectorAll('input, textarea').forEach(input => {\n                    const inputData = extractElementData(input);\n                    entryData[inputData.term] = inputData;\n                });\n                return entryData;\n            });\n    }\n    return data;\n}\n\n\nfunction datasetToTurtle(dataset) {\n    const writer = new N3Writer();\n    let turtleString = '';\n\n    writer.import(dataset.toStream())\n        .on('data', (chunk) => { turtleString += chunk; })\n        .on('end', () => {\n            console.log('Serialization complete');\n        });\n\n    return turtleString;\n}\n\n// Main extract function\nfunction extract(document) {\n    const form = document.querySelector('form');\n    const data = extractAllElementsData(form);\n    const dataset = createRDFNodes(data);\n    return datasetToTurtle(dataset);\n}\n\n// Make sure to export the extract function\nexport { extract };","import { extract } from './public/extractor.js';\n\n// Any other browser-specific initialization code\n\nwindow.extract = extract; // Make extract available globally"],"names":[],"sourceRoot":""}