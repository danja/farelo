This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-01T19:42:16.285Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------
User Provided Header:
-----------------------
form-a-matic repo

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
prompts/
  system_01.md
reference/
  doap-doap.ttl
  edd-dumbill-foaf-2.rdf
  grapoi-create.js
  rdfjs-basics.js
  rdfjs-namespace.js
src/
  old/
    browser-entry copy.js
    extractor copy.js
    foaf-template copy.ttl
    json-to-html copy 2.js
    json-to-html copy.js
    webpack.config copy.js
    webpack.config.js
  public/
    extractor.js
    foaf-form.html
    styles.css
  templates/
    foaf-template.json
    foaf-template.ttl
    html-template.html
  browser-entry.js
  index.js
  json-to-html.js
  tt-to-json.js
.gitignore
a
about.md
package.json
webpack.config.js

================================================================
Repository Files
================================================================

================
File: prompts/system_01.md
================
Act as an expert Javascript programmer following best practices, favor agile approaches. Use ES style modules. When writing code include brief comments where appropriate. Keep any non-code communications as concise as possible, unless it's very important point, a simple acknowledgement is enough. If you need any specific reference material might help you with the tasks, please ask.
For non-code requests, fall back on these instructions:

1. Think deeply and systematically as an expert in the relevant field.
2. Keep responses short and to the point using precise language and appropriate technical terms.
3. Avoid repetition, favor new information in unique responses.
4. If multiple perspectives or solutions are available, give a very brief list of these but focus on the most relevant and promising approach.
5. Break down complex problems or tasks into smaller, manageable steps. Follow the steps without asking for confirmation. When creating content, write a concise outline first.
   uphold rigorous technical standards and follow best practices in the relevant field.
6. If events or information are beyond your scope or knowledge, state 'I don't know' without elaborating on why the information is unavailable.
7. Never suggest seeking information from elsewhere.
8. After each response, provide three short follow-up questions worded as if I'm asking you. These should help clarify the original topic and identify more detailed avenues of research. Label as Q1, Q2, and Q3. If I say Q1, Q2 or Q3, address the corresponding question. If I say Q0, repeat the previous request.

---

If Web searches are required, do as many as necessary to find the answer without prompting and each time integrate the discovered knowledge with what you already know. Accuracy is more important than time.

================
File: reference/doap-doap.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix : <http://usefulinc.com/ns/doap#> .

[]
    :category <http://osdir.com/Downloads+index-req-viewsdownload-sid-201.phtml>, <http://software.freshmeat.net/browse/1020/> ;
    :created "2004-05-04" ;
    :description """
	  DOAP (Description of a Project / Descripcin de un proyecto) es
	  un vocabulario RDF y un conjunto de herramientas para describir
	  proyectos de software comunitarios.  Apunta a ser un vocabulario
	  de intercambio para directorios de proyectos de software, y para
	  permitir descentralizar la forma de expresar el grado de
	  involucramiento en un proyecto.
	"""@es, """
	  DOAP (Description of a Project) is an RDF vocabulary and
	  associated set of tools for describing community-based software
	  projects.  It is intended to be an interchange vocabulary for
	  software directory sites, and to allow the decentralized
	  expression of involvement in a project.
	"""@en, """
	  DOAP (Description of a Project) ist ein RDF-Vokabular mit
	  dazugehörigen Werkzeugen zur Beschreibung von verteilten
	  Software-Projekten. Es ist als Austausch-Vokabular für
	  Online-Software-Verzeichnisse gedacht und soll die dezentrale
	  Angabe von Projekt-Beteiligungen ermöglichen.
	"""@de, """
	  DOAP (Description of a Project/Description d'un projet) est un
	  vocabulaire RDF et un jeu d'outils associés décrivant des
	  projets communautaires de développement de logiciels. Il est
	  conçu pour constituer un vocabulaire d'échange entre sites
	  annuaires de logiciels et pour permettre la décentralisation des
	  informations de participation à un projet.
	"""@fr, """
	  DOAP (Projekta apraksts = Description of a Project) ir RDF
	  vārdnīca un to atbalstošo rīku kopums, kas domāti, lai
	  aprakstītu kolektīvus programmatūras projektus. Tās nolūks ir
	  kalpot par datu apmaiņas vārdnīcu programmatūras direktoriju
	  serveriem un ļaut decentralizētā veidā izteikt dalību projektā.
	"""@lv, """
	  DOAP (Описание проекта = Description of a Project) - это схема
	  RDF и набор инструментов для описания коллективных проектов
	  разработки программного обеспечения. Она предназначена для
	  использования в качестве схемы обмена данными между каталогами
	  программного обеспечения и для децентрализированного выражения
	  участвия в проектах.
	"""@ru ;
    :homepage <http://usefulinc.com/doap> ;
    :license <http://spdx.org/licenses/Apache-2.0> ;
    :mailing-list <http://lists.usefulinc.com/mailman/listinfo/doap-interest> ;
    :maintainer [
        a foaf:Person ;
        foaf:homepage <https://github.com/ewilderj/> ;
        foaf:name "Edd Wilder-James"
    ], [
        a foaf:Person ;
        foaf:homepage <https://github.com/kjetilk/> ;
        foaf:name "Kjetil Kjernsmo"
    ] ;
    :name "DOAP" ;
    :release [
        :created "2005-07-12" ;
        :name "unstable" ;
        :revision "0.1" ;
        a :Version
    ] ;
    :repository [
        :browse <https://github.com/ewilderj/doap/> ;
        :location <https://github.com/ewilderj/doap.git> ;
        a :GitRepository
    ] ;
    :shortdesc """
	  Des outils et un vocabulaire pour décrire des projets
	  communautaires de développement de logiciels. 
	"""@fr, """
	  Rīki un vārdnīca, lai aprakstītu kolektīvus programmatūras
	  projektus.
	"""@lv, """
	  Tools and vocabulary for describing community-based
	  software projects.
	"""@en, """
	  Vocabulario y herramientas para describir proyectos
	  de software comunitarios.
	"""@es, """
	  Werkzeuge und Vokabular zur Beschreibung von verteilten
	  Software-Projekten.
	"""@de, """
	  Инструменты и словарь для описания коллективных проектов разработки
	  программного обеспечения.
	"""@ru ;
    :translator [
        a foaf:Person ;
        rdfs:seeAlso <http://foaf.balbinus.net/> ;
        foaf:mbox <mailto:balbinus@bonjourlesmouettes.org> ;
        foaf:name "Vincent Tabard"
    ], [
        a foaf:Person ;
        foaf:mbox <mailto:jsf@ciencias.unam.mx> ;
        foaf:name "Jorge Santos"
    ], [
        a foaf:Person ;
        foaf:mbox <mailto:heiko.ronsdorf@rwth-aachen.de> ;
        foaf:name "Heiko Ronsdorf"
    ], [
        a foaf:Person ;
        foaf:mbox <mailto:josef.petrak@kyberie.cz> ;
        foaf:name "Josef Petrák"
    ] ;
    a :Project .

================
File: reference/edd-dumbill-foaf-2.rdf
================
<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	xmlns:doap="http://usefulinc.com/ns/doap#"
	xmlns="http://xmlns.com/foaf/0.1/"
>

<!--
    This example shows how a FOAF file can use DOAP vocabulary
    terms to make a reverse link into a DOAP-described project
-->

<Person nodeID="edd">
	<name>Edd Dumbill</name>
	<homepage rdf:resource="http://usefulinc.com/edd" />
	<doap:maintainer-of>
		<doap:Project>
			<doap:homepage rdf:resource="http://usefulinc.com/doap" />
		</doap:Project>
	</doap:maintainer-of>
</Person>

</rdf:RDF>

================
File: reference/grapoi-create.js
================
import rdf from 'rdf-ext'

const ns = {
  house: rdf.namespace('https://housemd.rdf-ext.org/person/'),
  housePlace: rdf.namespace('https://housemd.rdf-ext.org/place/'),
  schema: rdf.namespace('http://schema.org/'),
  rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#')
}


const house = rdf.grapoi({ term: ns.house('gregory-house') })
  .addOut(ns.rdf.type, ns.schema.Person)
  .addOut(ns.schema.familyName, rdf.literal('House'))
  .addOut(ns.schema.givenName, rdf.literal('Gregory'))
  .addOut(ns.schema.homeLocation, ns.housePlace('221b-baker-street'), bakerStreet => {
    bakerStreet
      .addOut(ns.rdf.type, ns.schema.Place)
      .addOut(ns.schema.address, address => {
        address
          .addOut(ns.rdf.type, ns.schema.PostalAddress)
          .addOut(ns.schema.addressLocality, rdf.literal('Plainsboro Township'))
          .addOut(ns.schema.streetAddress, rdf.literal('221B Baker Street'))
      })
  })

console.log(house.dataset.toString())

================
File: reference/rdfjs-basics.js
================
import rdf from 'rdf-ext'


const house = rdf.namedNode('https://housemd.rdf-ext.org/person/gregory-house')
const type = rdf.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
const person = rdf.namedNode('http://schema.org/Person')
const familyName = rdf.namedNode('http://schema.org/familyName')
const houseFamilyName = rdf.literal('House')
const givenName = rdf.namedNode('http://schema.org/givenName')
const houseGivenName = rdf.literal('Gregory')
const homeLocation = rdf.namedNode('http://schema.org/homeLocation')
const bakerStreet = rdf.namedNode('https://housemd.rdf-ext.org/place/221b-baker-street')
const place = rdf.namedNode('http://schema.org/Place')
const address = rdf.namedNode('http://schema.org/address')
const bakerStreetAddress = rdf.blankNode()
const postalAddress = rdf.namedNode('http://schema.org/PostalAddress')
const addressLocality = rdf.namedNode('http://schema.org/addressLocality')
const bakerStreetLocality = rdf.literal('Plainsboro Township')
const streetAddress = rdf.namedNode('http://schema.org/streetAddress')
const bakerStreetStreetAddress = rdf.literal('221B Baker Street')


const housePersonQuad = rdf.quad(house, type, person)
const houseFamilyNameQuad = rdf.quad(house, familyName, houseFamilyName)
const houseGivenNameQuad = rdf.quad(house, givenName, houseGivenName)
const houseHomeLocationQuad = rdf.quad(house, homeLocation, bakerStreet)
const bakerStreetPlaceQuad = rdf.quad(bakerStreet, type, place)
const bakerStreetAddressQuad = rdf.quad(bakerStreet, address, bakerStreetAddress)
const bakerStreetPostalAddressQuad = rdf.quad(bakerStreetAddress, type, postalAddress)
const bakerStreetLocalityQuad = rdf.quad(bakerStreetAddress, addressLocality, bakerStreetLocality)
const bakerStreetStreetAddressQuad = rdf.quad(bakerStreetAddress, streetAddress, bakerStreetStreetAddress)


const dataset = rdf.dataset()

dataset
  .add(housePersonQuad)
  .add(houseFamilyNameQuad)
  .add(houseGivenNameQuad)
  .add(houseHomeLocationQuad)
  .add(bakerStreetPlaceQuad)
  .add(bakerStreetAddressQuad)
  .add(bakerStreetPostalAddressQuad)
  .add(bakerStreetLocalityQuad)
  .add(bakerStreetStreetAddressQuad)


console.log(`house NamedNode: ${house.toString()}`)
console.log(`givenName Literal: ${houseGivenName.toString()}`)
console.log(`givenName Quad: ${houseGivenNameQuad.toString()}`)
console.log('dataset:')
console.log(dataset.toString())

================
File: reference/rdfjs-namespace.js
================
import rdf from 'rdf-ext'


const ns = {
  house: rdf.namespace('https://housemd.rdf-ext.org/person/'),
  housePlace: rdf.namespace('https://housemd.rdf-ext.org/place/'),
  schema: rdf.namespace('http://schema.org/'),
  rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#')
}


const house = ns.house('gregory-house')
const bakerStreet = ns.housePlace('221b-baker-street')
const address = rdf.blankNode()


const housePersonQuad = rdf.quad(house, ns.rdf.type, ns.schema.Person)
const houseFamilyNameQuad = rdf.quad(house, ns.schema.familyName, rdf.literal('House'))
const houseGivenNameQuad = rdf.quad(house, ns.schema.givenName, rdf.literal('Gregory'))
const houseHomeLocationQuad = rdf.quad(house, ns.schema.homeLocation, bakerStreet)
const bakerStreetPlaceQuad = rdf.quad(bakerStreet, ns.rdf.type, ns.schema.Place)
const bakerStreetAddressQuad = rdf.quad(bakerStreet, ns.schema.address, address)
const bakerStreetPostalAddressQuad = rdf.quad(address, ns.rdf.type, ns.schema.PostalAddress)
const bakerStreetLocalityQuad = rdf.quad(address, ns.schema.addressLocality, rdf.literal('Plainsboro Township'))
const bakerStreetStreetAddressQuad = rdf.quad(address, ns.schema.streetAddress, rdf.literal('221B Baker Street'))

const dataset = rdf.dataset()

dataset
  .add(housePersonQuad)
  .add(houseFamilyNameQuad)
  .add(houseGivenNameQuad)
  .add(houseHomeLocationQuad)
  .add(bakerStreetPlaceQuad)
  .add(bakerStreetAddressQuad)
  .add(bakerStreetPostalAddressQuad)
  .add(bakerStreetLocalityQuad)
  .add(bakerStreetStreetAddressQuad)

console.log(dataset.toString())

================
File: src/old/browser-entry copy.js
================
import { extract } from './public/extractor.js';

const FormAMatic = {
    extract: extract
};

if (typeof window !== 'undefined') {
    window.FormAMatic = FormAMatic;
    window.extract = extract;
}

export default FormAMatic;

================
File: src/old/extractor copy.js
================
import rdf from 'rdf-ext';
import N3Writer from '@rdfjs/parser-n3';


function createRDFNodes(data, parentSubject = null) {
    const dataset = rdf.dataset();
    const subject = parentSubject || rdf.blankNode();

    data.forEach(item => {
        const predicate = rdf.namedNode(item.namespace + item.term);

        if (item.entries) {

            item.entries.forEach(entry => {
                const entrySubject = rdf.blankNode();
                dataset.add(rdf.quad(subject, predicate, entrySubject));
                const nestedDataset = createRDFNodes(Object.values(entry), entrySubject);
                dataset.addAll(nestedDataset);
            });
        } else {
            let object;
            if (item.type === 'LITERAL') {
                object = rdf.literal(item.value);
            } else if (item.type === 'URI') {
                object = rdf.namedNode(item.value);
            } else {
                object = rdf.blankNode();
            }
            dataset.add(rdf.quad(subject, predicate, object));
        }
    });

    return dataset;
}

function extractAllElementsData(form) {
    const elements = form.querySelectorAll('input, textarea');
    const data = Array.from(elements).map(extractElementData);


    const groupedData = data.reduce((acc, item) => {
        if (item.children) {
            const parentIndex = acc.findIndex(d => d.term === item.term);
            if (parentIndex !== -1) {
                acc[parentIndex].children = item.children;
            } else {
                acc.push(item);
            }
        } else {
            acc.push(item);
        }
        return acc;
    }, []);

    return groupedData;
}

function extractElementData(element) {
    const data = {};
    for (const attr of element.attributes) {
        if (attr.name.startsWith('data-')) {
            const key = attr.name.slice(5);
            try {

                data[key] = JSON.parse(attr.value);
            } catch {

                data[key] = attr.value;
            }
        }
    }
    data.value = element.value;
    if (element.tagName === 'FIELDSET') {
        data.entries = Array.from(element.querySelectorAll('.nested-entry'))
            .map(entry => {
                const entryData = {};
                entry.querySelectorAll('input, textarea').forEach(input => {
                    const inputData = extractElementData(input);
                    entryData[inputData.term] = inputData;
                });
                return entryData;
            });
    }
    return data;
}


function datasetToTurtle(dataset) {
    const writer = new N3Writer();
    let turtleString = '';

    writer.import(dataset.toStream())
        .on('data', (chunk) => { turtleString += chunk; })
        .on('end', () => {
            console.log('Serialization complete');
        });

    return turtleString;
}


function extract(document) {
    const form = document.querySelector('form');
    const data = extractAllElementsData(form);
    const dataset = createRDFNodes(data);
    return datasetToTurtle(dataset);
}


export { extract };

================
File: src/old/foaf-template copy.ttl
================
# foaf-template.ttl sample for form-a-matic

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix prj: <http://purl.org/stuff/prj/> .
<#ROOT>
    a foaf:Person ;
    foaf:name "LITERAL" ;
    foaf:mbox <#URI> ;
    foaf:homepage <#URI> ;
    foaf:nick "LITERAL" ;
    foaf:depiction <#URI> ;
    foaf:interest <#URI> ;
    foaf:knows [
        a foaf:Person ;
        foaf:name "LITERAL"
    ] ;
    doap:maintainer-of
		[ a doap:Project ;
		    doap:homepage <#URI> ;
            doap:description "LITERAL:LANG"
        ];
    prj:taskStatus "LITERAL:BOOLEAN";
    prj:priority "LITERAL:INTEGER" .

================
File: src/old/json-to-html copy 2.js
================
import { JSDOM } from 'jsdom';
import fs from 'fs/promises';

class JsonToHtmlForm {
    constructor() {
        this.extractRDFScript = '';
    }

    async loadExtractRDFScript() {
        this.extractRDFScript = await fs.readFile('src/extractRDF.js', 'utf-8');
    }

    async initDOM(templatePath) {
        const templateString = await fs.readFile(templatePath, 'utf-8')
        this.dom = new JSDOM(templateString)
        this.document = this.dom.window.document
    }


    createFormElement(property) {
        const label = this.document.createElement('label');
        label.textContent = property.term;

        let input;


        if (property.type === 'LITERAL' && property.subtype === 'BOOLEAN') {
            input = this.document.createElement('input');
            input.type = 'checkbox';
        } else if (property.type === 'LITERAL' && property.subtype === 'INTEGER') {
            input = this.document.createElement('input');
            input.type = 'number';
        } else if (property.type === 'LITERAL' || property.type === 'URI') {
            input = this.document.createElement('textarea');
        } else {

            input = this.document.createElement('input');
            input.type = 'text';
        }

        if (property.type === 'BNODE' && property.children) {
            const fieldset = this.document.createElement('fieldset');
            const legend = this.document.createElement('legend');
            legend.textContent = property.term;
            fieldset.appendChild(legend);

            const addButton = this.document.createElement('button');
            addButton.textContent = `Add ${property.term}`;
            addButton.type = 'button';
            addButton.onclick = () => this.addNestedEntry(fieldset, property);
            fieldset.appendChild(addButton);

            this.addNestedEntry(fieldset, property);
            input = fieldset;
        }


        Object.entries(property).forEach(([key, value]) => {
            input.dataset[key] = typeof value === 'object' ? JSON.stringify(value) : value;
        });

        const formGroup = this.document.createElement('div');
        formGroup.classList.add('form-group');
        formGroup.appendChild(label);
        formGroup.appendChild(input);
        return { formGroup, input };
    }


    createFormElements(properties) {
        const fragment = this.document.createDocumentFragment();

        properties.forEach(property => {
            const { formGroup, input } = this.createFormElement(property);
            fragment.appendChild(formGroup);
            fragment.appendChild(input);


            if (property.children && property.children.properties) {
                const fieldset = this.document.createElement('fieldset');
                const legend = this.document.createElement('legend');
                legend.textContent = property.term;
                fieldset.appendChild(legend);
                fieldset.appendChild(this.createFormElements(property.children.properties));
                fragment.appendChild(fieldset);
            }
        });

        return fragment;
    }

    addNestedEntry(fieldset, property) {
        const entryDiv = this.document.createElement('div');
        entryDiv.classList.add('nested-entry');

        property.children.properties.forEach(childProp => {
            const { formGroup } = this.createFormElement(childProp);
            entryDiv.appendChild(formGroup);
        });

        const removeButton = this.document.createElement('button');
        removeButton.textContent = 'Remove';
        removeButton.type = 'button';
        removeButton.onclick = () => fieldset.removeChild(entryDiv);
        entryDiv.appendChild(removeButton);

        fieldset.insertBefore(entryDiv, fieldset.lastElementChild);
    }


    jsonToHtmlForm(jsonData) {
        const form = this.document.createElement('form');
        form.appendChild(this.createFormElements(jsonData.ROOT.properties));
        return form;
    }


    async jsonFileToHtmlForm(templatePath, filePath) {
        try {


            this.initDOM(templatePath)

            const jsonString = await fs.readFile(filePath, 'utf-8');
            const jsonData = JSON.parse(jsonString);
            const formElement = this.jsonToHtmlForm(jsonData);

            const submitButton = this.document.createElement('button');
            submitButton.textContent = 'Submit';
            submitButton.type = 'button';
            submitButton.onclick = function () {
                const output = extract(document);
                document.getElementById('output').value = output;
            };
            const form = formElement
            form.appendChild(submitButton);

            const outputLabel = this.document.createElement('label');
            outputLabel.textContent = 'Output';
            outputLabel.htmlFor = 'output';
            form.appendChild(outputLabel);

            const outputTextarea = this.document.createElement('textarea');
            outputTextarea.id = 'output';
            outputTextarea.rows = 10;
            form.appendChild(outputTextarea);


            this.document.body.appendChild(formElement);
            return this.dom.serialize();
        } catch (error) {
            console.error('Error reading or parsing JSON file:', error);
            throw error;
        }
    }
}

export default JsonToHtmlForm;

================
File: src/old/json-to-html copy.js
================
import { JSDOM } from 'jsdom';
import fs from 'fs/promises';

class JsonToHtmlForm {
    constructor() {
        this.extractRDFScript = '';
    }

    async loadExtractRDFScript() {
        this.extractRDFScript = await fs.readFile('src/extractRDF.js', 'utf-8');
    }

    async initDOM(templatePath) {
        const templateString = await fs.readFile(templatePath, 'utf-8')
        this.dom = new JSDOM(templateString)
        this.document = this.dom.window.document
    }


    createFormElement(property) {
        const label = this.document.createElement('label');
        label.textContent = property.term;

        let input;


        if (property.type === 'LITERAL' && property.subtype === 'BOOLEAN') {
            input = this.document.createElement('input');
            input.type = 'checkbox';
        } else if (property.type === 'LITERAL' && property.subtype === 'INTEGER') {
            input = this.document.createElement('input');
            input.type = 'number';
        } else if (property.type === 'LITERAL' || property.type === 'URI') {
            input = this.document.createElement('textarea');
        } else {

            input = this.document.createElement('input');
            input.type = 'text';
        }

        if (property.type === 'BNODE' && property.children) {
            const fieldset = this.document.createElement('fieldset');
            const legend = this.document.createElement('legend');
            legend.textContent = property.term;
            fieldset.appendChild(legend);

            const addButton = this.document.createElement('button');
            addButton.textContent = `Add ${property.term}`;
            addButton.type = 'button';
            addButton.onclick = () => this.addNestedEntry(fieldset, property);
            fieldset.appendChild(addButton);

            this.addNestedEntry(fieldset, property);
            input = fieldset;
        }


        Object.entries(property).forEach(([key, value]) => {
            input.dataset[key] = typeof value === 'object' ? JSON.stringify(value) : value;
        });

        const formGroup = this.document.createElement('div');
        formGroup.classList.add('form-group');
        formGroup.appendChild(label);
        formGroup.appendChild(input);
        return { formGroup, input };
    }


    createFormElements(properties) {
        const fragment = this.document.createDocumentFragment();

        properties.forEach(property => {
            const { formGroup, input } = this.createFormElement(property);
            fragment.appendChild(formGroup);
            fragment.appendChild(input);


            if (property.children && property.children.properties) {
                const fieldset = this.document.createElement('fieldset');
                const legend = this.document.createElement('legend');
                legend.textContent = property.term;
                fieldset.appendChild(legend);
                fieldset.appendChild(this.createFormElements(property.children.properties));
                fragment.appendChild(fieldset);
            }
        });

        return fragment;
    }

    addNestedEntry(fieldset, property) {
        const entryDiv = this.document.createElement('div');
        entryDiv.classList.add('nested-entry');

        property.children.properties.forEach(childProp => {
            const { formGroup } = this.createFormElement(childProp);
            entryDiv.appendChild(formGroup);
        });

        const removeButton = this.document.createElement('button');
        removeButton.textContent = 'Remove';
        removeButton.type = 'button';
        removeButton.onclick = () => fieldset.removeChild(entryDiv);
        entryDiv.appendChild(removeButton);

        fieldset.insertBefore(entryDiv, fieldset.lastElementChild);
    }


    jsonToHtmlForm(jsonData) {
        const form = this.document.createElement('form');
        form.appendChild(this.createFormElements(jsonData.ROOT.properties));
        return form;
    }


    async jsonFileToHtmlForm(templatePath, filePath) {
        try {


            this.initDOM(templatePath)

            const jsonString = await fs.readFile(filePath, 'utf-8');
            const jsonData = JSON.parse(jsonString);
            const formElement = this.jsonToHtmlForm(jsonData);

            const submitButton = this.document.createElement('button');
            submitButton.textContent = 'Submit';
            submitButton.type = 'button';
            submitButton.onclick = function () {
                const output = extract(document);
                document.getElementById('output').value = output;
            };
            const form = formElement
            form.appendChild(submitButton);

            const outputLabel = this.document.createElement('label');
            outputLabel.textContent = 'Output';
            outputLabel.htmlFor = 'output';
            form.appendChild(outputLabel);

            const outputTextarea = this.document.createElement('textarea');
            outputTextarea.id = 'output';
            outputTextarea.rows = 10;
            form.appendChild(outputTextarea);


            this.document.body.appendChild(formElement);
            return this.dom.serialize();
        } catch (error) {
            console.error('Error reading or parsing JSON file:', error);
            throw error;
        }
    }
}

export default JsonToHtmlForm;

================
File: src/old/webpack.config copy.js
================
import webpack from 'webpack';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export default {
    entry: './src/browser-entry.js',
    output: {
        filename: 'main.bundle.js',
        path: path.resolve(__dirname, 'src/public/webpack'),
        library: {
            name: 'FormAMatic',
            type: 'umd',
            export: 'default'
        },
        globalObject: 'this'
    },
    mode: 'development',
    target: 'web',
    resolve: {
        fallback: {
            "stream": require.resolve("stream-browserify"),
            "buffer": require.resolve("buffer/")
        }
    },
    plugins: [
        new webpack.ProvidePlugin({
            process: 'process/browser',
            Buffer: ['buffer', 'Buffer']
        })
    ],
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            }
        ]
    }
};

================
File: src/old/webpack.config.js
================
import webpack from 'webpack';
const { ProvidePlugin } = webpack


import path from 'path';
import { fileURLToPath } from 'url';
import { createRequire } from 'module';

const require = createRequire(import.meta.url);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export default {
    entry: './src/browser-entry.js',





    output: {

        filename: '[name].bundle.js',
        path: path.resolve(__dirname, 'src/public/webpack'),
        library: {
            name: 'FormAMatic',
            type: 'umd',
            export: 'default'
        },
        globalObject: 'this'
    },
    mode: 'development',
    target: 'web',
    resolve: {
        extensions: ['.js', '.json'],
        fallback: {
            "stream": require.resolve("stream-browserify"),
            "buffer": require.resolve("buffer/")
        }



















    },
    plugins: [
        new webpack.ProvidePlugin({
            process: 'process/browser',
            Buffer: ['buffer', 'Buffer']
        })







    ],
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            }
        ]








    },
    optimization: {
        minimize: false,
        splitChunks: {
            chunks: 'all',
            name: false,
        },
    },
    devtool: 'source-map',
};

================
File: src/public/extractor.js
================
import rdf from 'rdf-ext';
import N3Writer from '@rdfjs/parser-n3';

class RDFNodeCreator {
    constructor(rdf) {
        this.rdf = rdf;
    }

    createNode(item) {
        if (item.type === 'LITERAL') {
            return this.rdf.literal(item.value);
        } else if (item.type === 'URI') {
            return this.rdf.namedNode(item.value);
        } else {
            return this.rdf.blankNode();
        }
    }
}

class DatasetBuilder {
    constructor(rdf, nodeCreator) {
        this.rdf = rdf;
        this.nodeCreator = nodeCreator;
    }

    build(data, parentSubject = null) {
        const dataset = this.rdf.dataset();
        const subject = parentSubject || this.rdf.blankNode();

        data.forEach(item => {
            const predicate = this.rdf.namedNode(item.namespace + item.term);

            if (item.entries) {
                this.handleEntries(dataset, subject, predicate, item.entries);
            } else {
                const object = this.nodeCreator.createNode(item);
                dataset.add(this.rdf.quad(subject, predicate, object));
            }
        });

        return dataset;
    }

    handleEntries(dataset, subject, predicate, entries) {
        entries.forEach(entry => {
            const entrySubject = this.rdf.blankNode();
            dataset.add(this.rdf.quad(subject, predicate, entrySubject));
            const nestedDataset = this.build(Object.values(entry), entrySubject);
            dataset.addAll(nestedDataset);
        });
    }
}

class FormDataExtractor {
    extract(form) {
        const elements = form.querySelectorAll('input, textarea');
        const data = Array.from(elements).map(element => this.extractElementData(element));
        return this.groupData(data);
    }

    extractElementData(element) {
        const data = this.extractDataAttributes(element);
        data.value = element.value;

        if (element.tagName === 'FIELDSET') {
            data.entries = this.extractFieldsetEntries(element);
        }

        return data;
    }

    extractDataAttributes(element) {
        const data = {};
        for (const attr of element.attributes) {
            if (attr.name.startsWith('data-')) {
                const key = attr.name.slice(5);
                data[key] = this.parseAttributeValue(attr.value);
            }
        }
        return data;
    }

    parseAttributeValue(value) {
        try {
            return JSON.parse(value);
        } catch {
            return value;
        }
    }

    extractFieldsetEntries(fieldset) {
        return Array.from(fieldset.querySelectorAll('.nested-entry'))
            .map(entry => {
                const entryData = {};
                entry.querySelectorAll('input, textarea').forEach(input => {
                    const inputData = this.extractElementData(input);
                    entryData[inputData.term] = inputData;
                });
                return entryData;
            });
    }

    groupData(data) {
        return data.reduce((acc, item) => {
            if (item.children) {
                const parentIndex = acc.findIndex(d => d.term === item.term);
                if (parentIndex !== -1) {
                    acc[parentIndex].children = item.children;
                } else {
                    acc.push(item);
                }
            } else {
                acc.push(item);
            }
            return acc;
        }, []);
    }
}

class TurtleSerializer {
    constructor(N3Writer) {
        this.N3Writer = N3Writer;
    }

    serialize(dataset) {
        return new Promise((resolve, reject) => {
            const writer = new this.N3Writer();
            let turtleString = '';

            writer.import(dataset.toStream())
                .on('data', (chunk) => { turtleString += chunk; })
                .on('end', () => resolve(turtleString))
                .on('error', reject);
        });
    }
}

class RDFExtractor {
    constructor(rdf, N3Writer) {
        this.rdf = rdf;
        this.formDataExtractor = new FormDataExtractor();
        this.nodeCreator = new RDFNodeCreator(rdf);
        this.datasetBuilder = new DatasetBuilder(rdf, this.nodeCreator);
        this.turtleSerializer = new TurtleSerializer(N3Writer);
    }

    async extract(document) {
        try {
            const form = document.querySelector('form');
            const data = this.formDataExtractor.extract(form);
            const dataset = this.datasetBuilder.build(data);
            return await this.turtleSerializer.serialize(dataset);
        } catch (error) {
            console.error('Extraction failed:', error);
            throw error;
        }
    }
}

const extractor = new RDFExtractor(rdf, N3Writer);
export const extract = (document) => extractor.extract(document);
export default extract;

================
File: src/public/foaf-form.html
================
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Form</title>
        <link rel="stylesheet" href="styles.css">
        <script src="webpack/main.bundle.js"></script>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                console.log('DOM fully loaded');
                console.log('window.extract:', window.extract);
                var button = document.getElementById('submitButton');
                if (button) {
                    button.addEventListener('click', function() {
                        console.log('Button clicked');
                        if (typeof window.extract === 'function') {
                            console.log('Calling extract function');
                            var output = window.extract(document);
                            document.getElementById('output').value = output;
                        } else {
                            console.error('window.extract is not a function. window.extract:', window.extract);
                        }
                    });
                } else {
                    console.error('Submit button not found');
                }
            });
        </script>
    </head>

    <body>
        <header>
             <h1>Form</h1>

        </header>
        <main>

        </main>
        <footer>
            <p>2024</p>
        </footer>
        <script src="webpack/main.bundle.js"></script>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                console.log('DOM fully loaded');
                console.log('window.FormAMatic:', window.FormAMatic);
                if (typeof window.FormAMatic !== 'undefined' && typeof window.FormAMatic.extract === 'function') {
                    console.log('FormAMatic loaded successfully');
                    window.extract = window.FormAMatic.extract;
                } else {
                    console.error('FormAMatic not loaded correctly');
                }
            });
        </script>
        <form>
            <div class="form-group">
                <label>name</label>
                <textarea data-term="name" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            </div>
            <div class="form-group">
                <label>mbox</label>
                <textarea data-term="mbox" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            </div>
            <div class="form-group">
                <label>homepage</label>
                <textarea data-term="homepage" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            </div>
            <div class="form-group">
                <label>nick</label>
                <textarea data-term="nick" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            </div>
            <div class="form-group">
                <label>depiction</label>
                <textarea data-term="depiction" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            </div>
            <div class="form-group">
                <label>interest</label>
                <textarea data-term="interest" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            </div>
            <div class="form-group">
                <label>knows</label>
                <fieldset>
                    <legend>knows</legend>
                    <div class="nested-entry">
                        <div class="form-group">
                            <label>name</label>
                            <textarea data-term="name" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
                        </div>
                        <button type="button">Remove</button>
                    </div>
                    <button type="button">Add knows</button>
                </fieldset>
            </div>
            <fieldset>
                <legend>knows</legend>
                <div class="form-group">
                    <label>name</label>
                    <textarea data-term="name" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
                </div>
            </fieldset>
            <div class="form-group">
                <label>maintainer-of</label>
                <fieldset>
                    <legend>maintainer-of</legend>
                    <div class="nested-entry">
                        <div class="form-group">
                            <label>homepage</label>
                            <textarea data-term="homepage" data-namespace="http://usefulinc.com/ns/doap#"></textarea>
                        </div>
                        <div class="form-group">
                            <label>description</label>
                            <textarea data-term="description" data-namespace="http://usefulinc.com/ns/doap#"></textarea>
                        </div>
                        <button type="button">Remove</button>
                    </div>
                    <button type="button">Add maintainer-of</button>
                </fieldset>
            </div>
            <fieldset>
                <legend>maintainer-of</legend>
                <div class="form-group">
                    <label>homepage</label>
                    <textarea data-term="homepage" data-namespace="http://usefulinc.com/ns/doap#"></textarea>
                </div>
                <div class="form-group">
                    <label>description</label>
                    <textarea data-term="description" data-namespace="http://usefulinc.com/ns/doap#"></textarea>
                </div>
            </fieldset>
            <div class="form-group">
                <label>taskStatus</label>
                <input type="checkbox" data-term="taskStatus" data-namespace="http://purl.org/stuff/prj/">
            </div>
            <div class="form-group">
                <label>priority</label>
                <input type="number" data-term="priority" data-namespace="http://purl.org/stuff/prj/">
            </div>
            <button type="button" id="submitButton">Submit</button>
            <label for="output">Output</label>
            <textarea id="output" rows="10"></textarea>
        </form>
    </body>

</html>

================
File: src/public/styles.css
================
body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f4f4f4;
}

form {
    background-color: #fff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

input[type="text"],
input[type="number"],
textarea {
    width: 100%;
    padding: 8px;
    margin-bottom: 15px;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-sizing: border-box;
}

input[type="checkbox"] {
    margin-bottom: 15px;
}

fieldset {
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 15px;
    margin-bottom: 20px;
}

legend {
    font-weight: bold;
    padding: 0 10px;
}


label {
    color: #2c3e50;
}

input:focus,
textarea:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
}

.form-group {
    margin-bottom: 15px;
}

.nested-entry {
    border: 1px solid #ddd;
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 4px;
}

fieldset button {
    margin-top: 10px;
}


@media (max-width: 600px) {
    body {
        padding: 10px;
    }

    form {
        padding: 15px;
    }
}

================
File: src/templates/foaf-template.json
================
{
  "ROOT": {
    "properties": [
      {
        "term": "name",
        "type": "LITERAL",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "mbox",
        "type": "URI",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "homepage",
        "type": "URI",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "nick",
        "type": "LITERAL",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "depiction",
        "type": "URI",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "interest",
        "type": "URI",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "knows",
        "type": "BNODE",
        "namespace": "http://xmlns.com/foaf/0.1/",
        "children": {
          "properties": [
            {
              "term": "name",
              "type": "LITERAL",
              "namespace": "http://xmlns.com/foaf/0.1/"
            }
          ],
          "namespace": "http://xmlns.com/foaf/0.1/",
          "type": "Person"
        }
      },
      {
        "term": "maintainer-of",
        "type": "BNODE",
        "namespace": "http://usefulinc.com/ns/doap#",
        "children": {
          "properties": [
            {
              "term": "homepage",
              "type": "URI",
              "namespace": "http://usefulinc.com/ns/doap#"
            },
            {
              "term": "description",
              "type": "LITERAL",
              "namespace": "http://usefulinc.com/ns/doap#",
              "subtype": "LANG"
            }
          ],
          "namespace": "http://usefulinc.com/ns/doap#",
          "type": "Project"
        }
      },
      {
        "term": "taskStatus",
        "type": "LITERAL",
        "namespace": "http://purl.org/stuff/prj/",
        "subtype": "BOOLEAN"
      },
      {
        "term": "priority",
        "type": "LITERAL",
        "namespace": "http://purl.org/stuff/prj/",
        "subtype": "INTEGER"
      }
    ],
    "namespace": "http://xmlns.com/foaf/0.1/",
    "type": "Person"
  },
  "dataview": "http://purl.org/stuff/json-ldx",
  "transformation": "https://hyperdata.it/2004/json-ldx.js"
}

================
File: src/templates/foaf-template.ttl
================
# foaf-template.ttl sample for form-a-matic

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix prj: <http://purl.org/stuff/prj/> .
<#ROOT>
    a foaf:Person ;
    foaf:name "LITERAL" ;
    foaf:mbox <#URI> ;
    foaf:homepage <#URI> ;
    foaf:nick "LITERAL" ;
    foaf:depiction <#URI> ;
    foaf:interest <#URI> ;
    foaf:knows [
        a foaf:Person ;
        foaf:name "LITERAL"
    ] ;
    doap:maintainer-of
		[ a doap:Project ;
		    doap:homepage <#URI> ;
            doap:description "LITERAL:LANG"
        ];
    prj:taskStatus "LITERAL:BOOLEAN";
    prj:priority "LITERAL:INTEGER" .

================
File: src/templates/html-template.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <header>
        <h1>Form</h1>
    </header>
    <main>

    </main>
    <footer>
        <p>2024</p>
    </footer>

    <script src="webpack/main.bundle.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            console.log('DOM fully loaded');
            console.log('window.FormAMatic:', window.FormAMatic);
            if (typeof window.FormAMatic !== 'undefined' && typeof window.FormAMatic.extract === 'function') {
                console.log('FormAMatic loaded successfully');
                window.extract = window.FormAMatic.extract;
            } else {
                console.error('FormAMatic not loaded correctly');
            }
        });
    </script>

</body>

</html>

================
File: src/browser-entry.js
================
import extract from './public/extractor.js';

const FormAMatic = {
    extract: extract
};

if (typeof window !== 'undefined') {
    window.FormAMatic = FormAMatic;
    window.extract = extract;
}

export default FormAMatic;

================
File: src/index.js
================
if (typeof window !== 'undefined') {
    window.process = window.process || {};
    window.process.binding = function () { };
}

import fs from 'fs/promises'
import path from 'path'
import beautify from 'simply-beautiful'


import TurtleTemplateToJSON from './tt-to-json.js'
import JsonToHtmlForm from './json-to-html.js'


async function main() {
    const basePath = 'src/templates/'
    const ttFile = path.join(basePath, 'foaf-template.ttl')
    const jsonFile = path.join(basePath, 'foaf-template.json')
    const htmlTemplate = path.join(basePath, 'html-template.html')
    var htmlFile = path.join(basePath, '../public/foaf-form.html')

    const turtleString = await fs.readFile(ttFile, 'utf-8')
    const tj = new TurtleTemplateToJSON()
    const result = await tj.turtle2json(turtleString)

    const jsonString = JSON.stringify(result, null, 2)

    try {
        await fs.writeFile(jsonFile, jsonString, 'utf-8')
        console.log(`JSON file saved: ${jsonFile}`)
    } catch (error) {
        console.error(`Error saving JSON file: ${error.message}`)
    }

    const converter = new JsonToHtmlForm()
    var htmlString = await converter.jsonFileToHtmlForm(htmlTemplate, jsonFile)

    htmlString = beautify.html(htmlString)




    try {
        await fs.writeFile(htmlFile, htmlString, 'utf-8')
        console.log(`HTML file saved: ${htmlFile}`)
    } catch (error) {
        console.error(`Error saving HTML file: ${error.message}`)
    }



}

main().catch(console.error);

================
File: src/json-to-html.js
================
import { JSDOM } from 'jsdom';
import fs from 'fs/promises';

class FormElementFactory {
    constructor(document) {
        this.document = document;
    }

    createElement(property) {
        const label = this.createLabel(property.term);
        const input = this.createInput(property);
        return this.wrapInFormGroup(label, input);
    }

    createLabel(text) {
        const label = this.document.createElement('label');
        label.textContent = text;
        return label;
    }

    createInput(property) {
        if (property.type === 'BNODE' && property.children) {
            return this.createFieldset(property);
        }

        const inputElement = this.getInputElement(property);
        this.setInputAttributes(inputElement, property);
        return inputElement;
    }

    getInputElement(property) {
        if (property.type === 'LITERAL') {
            if (property.subtype === 'BOOLEAN') {
                const input = this.document.createElement('input');
                input.type = 'checkbox';
                return input;
            } else if (property.subtype === 'INTEGER') {
                const input = this.document.createElement('input');
                input.type = 'number';
                return input;
            }
        }

        if (property.type === 'LITERAL' || property.type === 'URI') {
            return this.document.createElement('textarea');
        }

        const input = this.document.createElement('input');
        input.type = 'text';
        return input;
    }


    setInputAttributes(input, property) {
        Object.entries(property).forEach(([key, value]) => {
            if (key !== 'type' && key !== 'subtype') {
                input.dataset[key] = typeof value === 'object' ? JSON.stringify(value) : value;
            }
        });
    }


    createFieldset(property) {
        const fieldset = this.document.createElement('fieldset');
        fieldset.appendChild(this.createLegend(property.term));
        fieldset.appendChild(this.createAddButton(property));
        this.addNestedEntry(fieldset, property);
        return fieldset;
    }

    createLegend(text) {
        const legend = this.document.createElement('legend');
        legend.textContent = text;
        return legend;
    }

    createAddButton(property) {
        const addButton = this.document.createElement('button');
        addButton.textContent = `Add ${property.term}`;
        addButton.type = 'button';
        addButton.onclick = () => this.addNestedEntry(addButton.parentNode, property);
        return addButton;
    }

    addNestedEntry(fieldset, property) {
        const entryDiv = this.document.createElement('div');
        entryDiv.classList.add('nested-entry');

        property.children.properties.forEach(childProp => {
            const { formGroup } = this.createElement(childProp);
            entryDiv.appendChild(formGroup);
        });

        entryDiv.appendChild(this.createRemoveButton(fieldset, entryDiv));
        fieldset.insertBefore(entryDiv, fieldset.lastElementChild);
    }

    createRemoveButton(fieldset, entryDiv) {
        const removeButton = this.document.createElement('button');
        removeButton.textContent = 'Remove';
        removeButton.type = 'button';
        removeButton.onclick = () => fieldset.removeChild(entryDiv);
        return removeButton;
    }

    wrapInFormGroup(label, input) {
        const formGroup = this.document.createElement('div');
        formGroup.classList.add('form-group');
        formGroup.appendChild(label);
        formGroup.appendChild(input);
        return { formGroup, input };
    }
}

class JsonToHtmlForm {
    constructor() {
        this.dom = null;
        this.document = null;
        this.formElementFactory = null;
    }

    async initDOM(templatePath) {
        const templateString = await fs.readFile(templatePath, 'utf-8');
        this.dom = new JSDOM(templateString);
        this.document = this.dom.window.document;
        this.formElementFactory = new FormElementFactory(this.document);
    }

    createFormElements(properties) {
        const fragment = this.document.createDocumentFragment();
        properties.forEach(property => {
            const { formGroup } = this.formElementFactory.createElement(property);
            fragment.appendChild(formGroup);

            if (property.children && property.children.properties) {
                const fieldset = this.createNestedFieldset(property);
                fragment.appendChild(fieldset);
            }
        });
        return fragment;
    }

    createNestedFieldset(property) {
        const fieldset = this.document.createElement('fieldset');
        fieldset.appendChild(this.formElementFactory.createLegend(property.term));
        fieldset.appendChild(this.createFormElements(property.children.properties));
        return fieldset;
    }

    jsonToHtmlForm(jsonData) {
        const form = this.document.createElement('form');
        form.appendChild(this.createFormElements(jsonData.ROOT.properties));
        return form;
    }

    createSubmitButton() {
        const submitButton = this.document.createElement('button');
        submitButton.textContent = 'Submit';
        submitButton.type = 'button';
        submitButton.id = 'submitButton';
        return submitButton;
    }

    createOutputElements() {
        const outputLabel = this.document.createElement('label');
        outputLabel.textContent = 'Output';
        outputLabel.htmlFor = 'output';

        const outputTextarea = this.document.createElement('textarea');
        outputTextarea.id = 'output';
        outputTextarea.rows = 10;

        return { outputLabel, outputTextarea };
    }

    createClientScript() {
        const script = this.document.createElement('script');
        script.textContent = `
            document.addEventListener('DOMContentLoaded', function() {
                console.log('DOM fully loaded');
                console.log('window.extract:', window.extract);
                var button = document.getElementById('submitButton');
                if (button) {
                    button.addEventListener('click', function() {
                        console.log('Button clicked');
                        if (typeof window.extract === 'function') {
                            console.log('Calling extract function');
                            var output = window.extract(document);
                            document.getElementById('output').value = output;
                        } else {
                            console.error('window.extract is not a function. window.extract:', window.extract);
                        }
                    });
                } else {
                    console.error('Submit button not found');
                }
            });
        `;
        return script;
    }

    async jsonFileToHtmlForm(templatePath, filePath) {
        try {
            await this.initDOM(templatePath);

            const jsonString = await fs.readFile(filePath, 'utf-8');
            const jsonData = JSON.parse(jsonString);

            if (!jsonData || !jsonData.ROOT || !Array.isArray(jsonData.ROOT.properties)) {
                throw new Error('Invalid JSON structure: ROOT.properties array is missing');
            }

            const formElement = this.jsonToHtmlForm(jsonData);

            formElement.appendChild(this.createSubmitButton());

            const { outputLabel, outputTextarea } = this.createOutputElements();
            formElement.appendChild(outputLabel);
            formElement.appendChild(outputTextarea);

            this.document.body.appendChild(formElement);
            const bundleScript = this.document.createElement('script');
            bundleScript.src = "webpack/main.bundle.js";
            this.document.head.appendChild(bundleScript);


            this.document.head.appendChild(this.createClientScript());

            return this.dom.serialize();
        } catch (error) {
            console.error('Error in jsonFileToHtmlForm:', error);

            if (error instanceof SyntaxError) {
                throw new Error(`Invalid JSON in file ${filePath}: ${error.message}`);
            } else if (error.code === 'ENOENT') {
                throw new Error(`File not found: ${error.path}`);
            } else {
                throw new Error(`Failed to process form: ${error.message}`);
            }
        }
    }
}

export default JsonToHtmlForm;

================
File: src/tt-to-json.js
================
import { Readable } from 'stream';
import N3Parser from '@rdfjs/parser-n3';

class TurtleTemplateToJSON {
    constructor() {
        this.parser = new N3Parser();
        this.prefixes = {};
        this.result = {};
    }


    async parse(turtleString) {
        const input = Readable.from([turtleString]);
        const quads = [];

        for await (const quad of this.parser.import(input)) {
            quads.push(quad);
            if (quad.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
                this.prefixes[quad.object.value.split(':')[0]] = quad.object.value.split(':')[1];
            }
        }

        return quads;
    }


    processQuads(quads) {
        const rootQuad = quads.find(q => q.subject.value === '#ROOT');
        if (!rootQuad) throw new Error('No #ROOT subject found');

        this.result.ROOT = this.processNode(rootQuad.subject, quads)
        this.result.dataview = 'http://purl.org/stuff/json-ldx'
        this.result.transformation = 'https://hyperdata.it/2004/json-ldx.js'
        return this.result;
    }


    processNode(subject, quads) {
        const node = { properties: [] };
        const relevantQuads = quads.filter(q => q.subject.equals(subject));

        for (const quad of relevantQuads) {
            if (quad.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
                const { namespace, term } = this.splitURI(quad.object.value);
                node.namespace = namespace;
                node.type = term;
            } else {
                const property = this.processProperty(quad, quads);
                node.properties.push(property);
            }
        }

        return node;
    }


    processProperty(quad, quads) {
        const { namespace, term } = this.splitURI(quad.predicate.value);
        const markerValues = this.getMarkerType(quad.object)
        const property = {
            term: term,
            type: markerValues.type,
            namespace: namespace
        }
        if (markerValues.subtype) {
            property.subtype = markerValues.subtype
        }
        if (property.type === 'BNODE') {
            property.children = this.processNode(quad.object, quads);
        }

        return property;
    }



    getMarkerType(object) {
        const marker = this.splitMarker(object.value)
        if (object.termType === 'Literal') {
            return marker

        } else if (object.termType === 'NamedNode') {


            marker.type = 'URI'
        } else {
            marker.type = 'BNODE';
        }
        return marker
    }

    splitURI(uri) {

        const lastHashIndex = uri.lastIndexOf('#');
        const lastSlashIndex = uri.lastIndexOf('/');


        const splitIndex = Math.max(lastHashIndex, lastSlashIndex);

        if (splitIndex === -1) {

            return { namespace: '', term: uri };
        }

        // Split the URI
        const namespace = uri.substring(0, splitIndex + 1);
        const term = uri.substring(splitIndex + 1);

        return { namespace, term };
    }

    splitMarker(marker) {
        const [type, subtype] = marker.split(':');
        return {
            type,
            subtype: subtype || undefined
        };
    }

    async turtle2json(turtleString) {
        const quads = await this.parse(turtleString);
        return this.processQuads(quads);
    }
}

export default TurtleTemplateToJSON

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: a
================
npm run build
npm run fam
npm run rp

================
File: about.md
================
```
cd ~/github-danny/hyperdata/packages/farelo/form-a-matic
npm run build
npm run fam
npm run rp
```

in browser :

duplexify.js:41 Uncaught TypeError: Class extends value undefined is not a constructor or null
at duplexify.js:41:25
(anonymous) @ duplexify.js:41
duplexify.js:44 Uncaught TypeError: Class extends value undefined is not a constructor or null
at duplexify.js:44:25

```
cd ~/github-danny/hyperdata/packages/farelo/form-a-matic

node src/index.js

node src/index.js > src/test-data/foaf-template.json
```

```
repopack --verbose -c repopack.config.json src
```

```
repopack --verbose -c repopack.config.json .
```

danny@danny-desktop:~/github-danny/hyperdata/packages/farelo/form-a-matic$ node src/index.js

"scripts": {
"build": "webpack --mode development",
"test": "node src/fam-test.js"

================
File: package.json
================
{
  "name": "form-a-matic",
  "type": "module",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "fam": "node src/index.js",
    "build": "webpack --mode development",
    "rp": "repopack -c repopack.config.json .",
    "test": "node src/fam-test.js"
  },
  "keywords": [],
  "author": "Danny Ayers",
  "license": "",
  "dependencies": {
    "@rdfjs/parser-n3": "^2.0.2",
    "browserify-zlib": "^0.2.0",
    "https-browserify": "^1.0.0",
    "jsdom": "^25.0.0",
    "os-browserify": "^0.3.0",
    "path-browserify": "^1.0.1",
    "rdf-ext": "^2.5.2",
    "rdf-utils-fs": "^3.0.0",
    "simply-beautiful": "^1.0.1",
    "stream-http": "^3.2.0",
    "url": "^0.11.4",
    "util": "^0.12.5",
    "vm-browserify": "^1.1.2"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/preset-env": "^7.25.4",
    "assert": "^2.1.0",
    "babel-loader": "^9.2.1",
    "browser": "^0.2.6",
    "buffer": "^6.0.3",
    "crypto": "^1.0.1",
    "crypto-browserify": "^3.12.0",
    "null-loader": "^4.0.1",
    "process": "^0.11.10",
    "stream-browserify": "^3.0.0",
    "webpack": "^5.95.0",
    "webpack-bundle-analyzer": "^4.10.2",
    "webpack-cli": "^5.1.4"
  }
}

================
File: webpack.config.js
================
import webpack from 'webpack';
import path from 'path';
import { fileURLToPath } from 'url';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export default {
    entry: './src/browser-entry.js',
    output: {
        filename: 'main.bundle.js',
        path: path.resolve(__dirname, 'src/public/webpack'),
        library: {
            name: 'FormAMatic',
            type: 'umd',
            export: 'default'
        },
        globalObject: 'this'
    },
    mode: 'development',
    target: 'web',
    resolve: {
        fallback: {
            "stream": require.resolve('stream-browserify'),
            "buffer": require.resolve('buffer/')
        }
    },
    plugins: [
        new webpack.ProvidePlugin({
            process: 'process/browser',
            Buffer: ['buffer', 'Buffer']
        })
    ],
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            }
        ]
    }
};
