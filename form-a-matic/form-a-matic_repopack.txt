================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-09-26T12:16:41.129Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
form-a-matic repo

================================================================
Repository Files
================================================================

================
File: about.md
================
```
cd ~/github-danny/hyperdata/packages/farelo/form-a-matic

node src/index.js

node src/index.js > src/test-data/foaf-template.json
```

```
repopack --verbose -c repopack.config.json src
```

```
repopack --verbose -c repopack.config.json .
```

danny@danny-desktop:~/github-danny/hyperdata/packages/farelo/form-a-matic$ node src/index.js

================
File: package.json
================
{
  "name": "form-a-matic",
  "type": "module",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "node src/fam-test.js"
  },
  "keywords": [],
  "author": "Danny Ayers",
  "license": "",
  "dependencies": {
    "@rdfjs/parser-n3": "^2.0.2",
    "jsdom": "^25.0.0",
    "rdf-ext": "^2.5.2",
    "rdf-utils-fs": "^3.0.0",
    "simply-beautiful": "^1.0.1"
  }
}

================
File: reference/doap-doap.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix : <http://usefulinc.com/ns/doap#> .

[]
    :category <http://osdir.com/Downloads+index-req-viewsdownload-sid-201.phtml>, <http://software.freshmeat.net/browse/1020/> ;
    :created "2004-05-04" ;
    :description """
	  DOAP (Description of a Project / Descripcin de un proyecto) es
	  un vocabulario RDF y un conjunto de herramientas para describir
	  proyectos de software comunitarios.  Apunta a ser un vocabulario
	  de intercambio para directorios de proyectos de software, y para
	  permitir descentralizar la forma de expresar el grado de
	  involucramiento en un proyecto.
	"""@es, """
	  DOAP (Description of a Project) is an RDF vocabulary and
	  associated set of tools for describing community-based software
	  projects.  It is intended to be an interchange vocabulary for
	  software directory sites, and to allow the decentralized
	  expression of involvement in a project.
	"""@en, """
	  DOAP (Description of a Project) ist ein RDF-Vokabular mit
	  dazugehörigen Werkzeugen zur Beschreibung von verteilten
	  Software-Projekten. Es ist als Austausch-Vokabular für
	  Online-Software-Verzeichnisse gedacht und soll die dezentrale
	  Angabe von Projekt-Beteiligungen ermöglichen.
	"""@de, """
	  DOAP (Description of a Project/Description d'un projet) est un
	  vocabulaire RDF et un jeu d'outils associés décrivant des
	  projets communautaires de développement de logiciels. Il est
	  conçu pour constituer un vocabulaire d'échange entre sites
	  annuaires de logiciels et pour permettre la décentralisation des
	  informations de participation à un projet.
	"""@fr, """
	  DOAP (Projekta apraksts = Description of a Project) ir RDF
	  vārdnīca un to atbalstošo rīku kopums, kas domāti, lai
	  aprakstītu kolektīvus programmatūras projektus. Tās nolūks ir
	  kalpot par datu apmaiņas vārdnīcu programmatūras direktoriju
	  serveriem un ļaut decentralizētā veidā izteikt dalību projektā.
	"""@lv, """
	  DOAP (Описание проекта = Description of a Project) - это схема
	  RDF и набор инструментов для описания коллективных проектов
	  разработки программного обеспечения. Она предназначена для
	  использования в качестве схемы обмена данными между каталогами
	  программного обеспечения и для децентрализированного выражения
	  участвия в проектах.
	"""@ru ;
    :homepage <http://usefulinc.com/doap> ;
    :license <http://spdx.org/licenses/Apache-2.0> ;
    :mailing-list <http://lists.usefulinc.com/mailman/listinfo/doap-interest> ;
    :maintainer [
        a foaf:Person ;
        foaf:homepage <https://github.com/ewilderj/> ;
        foaf:name "Edd Wilder-James"
    ], [
        a foaf:Person ;
        foaf:homepage <https://github.com/kjetilk/> ;
        foaf:name "Kjetil Kjernsmo"
    ] ;
    :name "DOAP" ;
    :release [
        :created "2005-07-12" ;
        :name "unstable" ;
        :revision "0.1" ;
        a :Version
    ] ;
    :repository [
        :browse <https://github.com/ewilderj/doap/> ;
        :location <https://github.com/ewilderj/doap.git> ;
        a :GitRepository
    ] ;
    :shortdesc """
	  Des outils et un vocabulaire pour décrire des projets
	  communautaires de développement de logiciels. 
	"""@fr, """
	  Rīki un vārdnīca, lai aprakstītu kolektīvus programmatūras
	  projektus.
	"""@lv, """
	  Tools and vocabulary for describing community-based
	  software projects.
	"""@en, """
	  Vocabulario y herramientas para describir proyectos
	  de software comunitarios.
	"""@es, """
	  Werkzeuge und Vokabular zur Beschreibung von verteilten
	  Software-Projekten.
	"""@de, """
	  Инструменты и словарь для описания коллективных проектов разработки
	  программного обеспечения.
	"""@ru ;
    :translator [
        a foaf:Person ;
        rdfs:seeAlso <http://foaf.balbinus.net/> ;
        foaf:mbox <mailto:balbinus@bonjourlesmouettes.org> ;
        foaf:name "Vincent Tabard"
    ], [
        a foaf:Person ;
        foaf:mbox <mailto:jsf@ciencias.unam.mx> ;
        foaf:name "Jorge Santos"
    ], [
        a foaf:Person ;
        foaf:mbox <mailto:heiko.ronsdorf@rwth-aachen.de> ;
        foaf:name "Heiko Ronsdorf"
    ], [
        a foaf:Person ;
        foaf:mbox <mailto:josef.petrak@kyberie.cz> ;
        foaf:name "Josef Petrák"
    ] ;
    a :Project .

================
File: reference/edd-dumbill-foaf-2.rdf
================
<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	xmlns:doap="http://usefulinc.com/ns/doap#"
	xmlns="http://xmlns.com/foaf/0.1/"
>

<!--
    This example shows how a FOAF file can use DOAP vocabulary
    terms to make a reverse link into a DOAP-described project
-->

<Person nodeID="edd">
	<name>Edd Dumbill</name>
	<homepage rdf:resource="http://usefulinc.com/edd" />
	<doap:maintainer-of>
		<doap:Project>
			<doap:homepage rdf:resource="http://usefulinc.com/doap" />
		</doap:Project>
	</doap:maintainer-of>
</Person>

</rdf:RDF>

================
File: reference/grapoi-create.js
================

import rdf from 'rdf-ext'
const ns = {
  house: rdf.namespace('https://housemd.rdf-ext.org/person/'),
  housePlace: rdf.namespace('https://housemd.rdf-ext.org/place/'),
  schema: rdf.namespace('http://schema.org/'),
  rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#')
}
const house = rdf.grapoi({ term: ns.house('gregory-house') })
  .addOut(ns.rdf.type, ns.schema.Person)
  .addOut(ns.schema.familyName, rdf.literal('House'))
  .addOut(ns.schema.givenName, rdf.literal('Gregory'))
  .addOut(ns.schema.homeLocation, ns.housePlace('221b-baker-street'), bakerStreet => {
    bakerStreet
      .addOut(ns.rdf.type, ns.schema.Place)
      .addOut(ns.schema.address, address => {
        address
          .addOut(ns.rdf.type, ns.schema.PostalAddress)
          .addOut(ns.schema.addressLocality, rdf.literal('Plainsboro Township'))
          .addOut(ns.schema.streetAddress, rdf.literal('221B Baker Street'))
      })
  })
console.log(house.dataset.toString())

================
File: reference/rdfjs-basics.js
================

import rdf from 'rdf-ext'
const house = rdf.namedNode('https://housemd.rdf-ext.org/person/gregory-house')
const type = rdf.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
const person = rdf.namedNode('http://schema.org/Person')
const familyName = rdf.namedNode('http://schema.org/familyName')
const houseFamilyName = rdf.literal('House')
const givenName = rdf.namedNode('http://schema.org/givenName')
const houseGivenName = rdf.literal('Gregory')
const homeLocation = rdf.namedNode('http://schema.org/homeLocation')
const bakerStreet = rdf.namedNode('https://housemd.rdf-ext.org/place/221b-baker-street')
const place = rdf.namedNode('http://schema.org/Place')
const address = rdf.namedNode('http://schema.org/address')
const bakerStreetAddress = rdf.blankNode()
const postalAddress = rdf.namedNode('http://schema.org/PostalAddress')
const addressLocality = rdf.namedNode('http://schema.org/addressLocality')
const bakerStreetLocality = rdf.literal('Plainsboro Township')
const streetAddress = rdf.namedNode('http://schema.org/streetAddress')
const bakerStreetStreetAddress = rdf.literal('221B Baker Street')
const housePersonQuad = rdf.quad(house, type, person)
const houseFamilyNameQuad = rdf.quad(house, familyName, houseFamilyName)
const houseGivenNameQuad = rdf.quad(house, givenName, houseGivenName)
const houseHomeLocationQuad = rdf.quad(house, homeLocation, bakerStreet)
const bakerStreetPlaceQuad = rdf.quad(bakerStreet, type, place)
const bakerStreetAddressQuad = rdf.quad(bakerStreet, address, bakerStreetAddress)
const bakerStreetPostalAddressQuad = rdf.quad(bakerStreetAddress, type, postalAddress)
const bakerStreetLocalityQuad = rdf.quad(bakerStreetAddress, addressLocality, bakerStreetLocality)
const bakerStreetStreetAddressQuad = rdf.quad(bakerStreetAddress, streetAddress, bakerStreetStreetAddress)
const dataset = rdf.dataset()
dataset
  .add(housePersonQuad)
  .add(houseFamilyNameQuad)
  .add(houseGivenNameQuad)
  .add(houseHomeLocationQuad)
  .add(bakerStreetPlaceQuad)
  .add(bakerStreetAddressQuad)
  .add(bakerStreetPostalAddressQuad)
  .add(bakerStreetLocalityQuad)
  .add(bakerStreetStreetAddressQuad)
console.log(`house NamedNode: ${house.toString()}`)
console.log(`givenName Literal: ${houseGivenName.toString()}`)
console.log(`givenName Quad: ${houseGivenNameQuad.toString()}`)
console.log('dataset:')
console.log(dataset.toString())

================
File: reference/rdfjs-namespace.js
================

import rdf from 'rdf-ext'
const ns = {
  house: rdf.namespace('https://housemd.rdf-ext.org/person/'),
  housePlace: rdf.namespace('https://housemd.rdf-ext.org/place/'),
  schema: rdf.namespace('http://schema.org/'),
  rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#')
}
const house = ns.house('gregory-house')
const bakerStreet = ns.housePlace('221b-baker-street')
const address = rdf.blankNode()
const housePersonQuad = rdf.quad(house, ns.rdf.type, ns.schema.Person)
const houseFamilyNameQuad = rdf.quad(house, ns.schema.familyName, rdf.literal('House'))
const houseGivenNameQuad = rdf.quad(house, ns.schema.givenName, rdf.literal('Gregory'))
const houseHomeLocationQuad = rdf.quad(house, ns.schema.homeLocation, bakerStreet)
const bakerStreetPlaceQuad = rdf.quad(bakerStreet, ns.rdf.type, ns.schema.Place)
const bakerStreetAddressQuad = rdf.quad(bakerStreet, ns.schema.address, address)
const bakerStreetPostalAddressQuad = rdf.quad(address, ns.rdf.type, ns.schema.PostalAddress)
const bakerStreetLocalityQuad = rdf.quad(address, ns.schema.addressLocality, rdf.literal('Plainsboro Township'))
const bakerStreetStreetAddressQuad = rdf.quad(address, ns.schema.streetAddress, rdf.literal('221B Baker Street'))
const dataset = rdf.dataset()
dataset
  .add(housePersonQuad)
  .add(houseFamilyNameQuad)
  .add(houseGivenNameQuad)
  .add(houseHomeLocationQuad)
  .add(bakerStreetPlaceQuad)
  .add(bakerStreetAddressQuad)
  .add(bakerStreetPostalAddressQuad)
  .add(bakerStreetLocalityQuad)
  .add(bakerStreetStreetAddressQuad)
console.log(dataset.toString())

================
File: src/index.js
================

import fs from 'fs/promises'
import path from 'path'
import beautify from 'simply-beautiful'
import TurtleTemplateToJSON from './tt-to-json.js'
import JsonToHtmlForm from './json-to-html.js'
async function main() {
    const basePath = 'src/templates/'
    const ttFile = path.join(basePath, 'foaf-template.ttl')
    const jsonFile = path.join(basePath, 'foaf-template.json')
    const htmlTemplate = path.join(basePath, 'html-template.html')
    var htmlFile = path.join(basePath, '../public/foaf-form.html')
    const turtleString = await fs.readFile(ttFile, 'utf-8')
    const tj = new TurtleTemplateToJSON()
    const result = await tj.turtle2json(turtleString)
    const jsonString = JSON.stringify(result, null, 2)
    try {
        await fs.writeFile(jsonFile, jsonString, 'utf-8')
        console.log(`JSON file saved: ${jsonFile}`)
    } catch (error) {
        console.error(`Error saving JSON file: ${error.message}`)
    }
    const converter = new JsonToHtmlForm()
    var htmlString = await converter.jsonFileToHtmlForm(htmlTemplate, jsonFile)
    htmlString = beautify.html(htmlString)
    try {
        await fs.writeFile(htmlFile, htmlString, 'utf-8')
        console.log(`HTML file saved: ${htmlFile}`)
    } catch (error) {
        console.error(`Error saving HTML file: ${error.message}`)
    }
}
main().catch(console.error);

================
File: src/json-to-html.js
================
import { JSDOM } from 'jsdom';
import fs from 'fs/promises';
class JsonToHtmlForm {
    constructor() {
        this.extractRDFScript = '';
    }
    async loadExtractRDFScript() {
        this.extractRDFScript = await fs.readFile('src/extractRDF.js', 'utf-8');
    }
    async initDOM(templatePath) {
        const templateString = await fs.readFile(templatePath, 'utf-8')
        this.dom = new JSDOM(templateString)
        this.document = this.dom.window.document
    }
    createFormElement(property) {
        const label = this.document.createElement('label');
        label.textContent = property.term;
        let input;
        if (property.type === 'LITERAL' && property.subtype === 'BOOLEAN') {
            input = this.document.createElement('input');
            input.type = 'checkbox';
        } else if (property.type === 'LITERAL' && property.subtype === 'INTEGER') {
            input = this.document.createElement('input');
            input.type = 'number';
        } else if (property.type === 'LITERAL' || property.type === 'URI') {
            input = this.document.createElement('textarea');
        } else {
            input = this.document.createElement('input');
            input.type = 'text';
        }
        if (property.type === 'BNODE' && property.children) {
            const fieldset = this.document.createElement('fieldset');
            const legend = this.document.createElement('legend');
            legend.textContent = property.term;
            fieldset.appendChild(legend);
            const addButton = this.document.createElement('button');
            addButton.textContent = `Add ${property.term}`;
            addButton.type = 'button';
            addButton.onclick = () => this.addNestedEntry(fieldset, property);
            fieldset.appendChild(addButton);
            this.addNestedEntry(fieldset, property);
            input = fieldset;
        }
        Object.entries(property).forEach(([key, value]) => {
            input.dataset[key] = typeof value === 'object' ? JSON.stringify(value) : value;
        });
        const formGroup = this.document.createElement('div');
        formGroup.classList.add('form-group');
        formGroup.appendChild(label);
        formGroup.appendChild(input);
        return { formGroup, input };
    }
    createFormElements(properties) {
        const fragment = this.document.createDocumentFragment();
        properties.forEach(property => {
            const { formGroup, input } = this.createFormElement(property);
            fragment.appendChild(formGroup);
            fragment.appendChild(input);
            if (property.children && property.children.properties) {
                const fieldset = this.document.createElement('fieldset');
                const legend = this.document.createElement('legend');
                legend.textContent = property.term;
                fieldset.appendChild(legend);
                fieldset.appendChild(this.createFormElements(property.children.properties));
                fragment.appendChild(fieldset);
            }
        });
        return fragment;
    }
    addNestedEntry(fieldset, property) {
        const entryDiv = this.document.createElement('div');
        entryDiv.classList.add('nested-entry');
        property.children.properties.forEach(childProp => {
            const { formGroup } = this.createFormElement(childProp);
            entryDiv.appendChild(formGroup);
        });
        const removeButton = this.document.createElement('button');
        removeButton.textContent = 'Remove';
        removeButton.type = 'button';
        removeButton.onclick = () => fieldset.removeChild(entryDiv);
        entryDiv.appendChild(removeButton);
        fieldset.insertBefore(entryDiv, fieldset.lastElementChild);
    }
    jsonToHtmlForm(jsonData) {
        const form = this.document.createElement('form');
        form.appendChild(this.createFormElements(jsonData.ROOT.properties));
        return form;
    }
    async jsonFileToHtmlForm(templatePath, filePath) {
        try {
            this.initDOM(templatePath)
            const jsonString = await fs.readFile(filePath, 'utf-8');
            const jsonData = JSON.parse(jsonString);
            const formElement = this.jsonToHtmlForm(jsonData);
            const submitButton = this.document.createElement('button');
            submitButton.textContent = 'Submit';
            submitButton.type = 'button';
            submitButton.onclick = function () {
                const output = extract(document);
                document.getElementById('output').value = output;
            };
            const form = formElement
            form.appendChild(submitButton);
            const outputLabel = this.document.createElement('label');
            outputLabel.textContent = 'Output';
            outputLabel.htmlFor = 'output';
            form.appendChild(outputLabel);
            const outputTextarea = this.document.createElement('textarea');
            outputTextarea.id = 'output';
            outputTextarea.rows = 10;
            form.appendChild(outputTextarea);
            this.document.body.appendChild(formElement);
            return this.dom.serialize();
        } catch (error) {
            console.error('Error reading or parsing JSON file:', error);
            throw error;
        }
    }
}
export default JsonToHtmlForm;

================
File: src/public/extractor.js
================
import rdf from 'rdf-ext';
import N3Writer from '@rdfjs/parser-n3';
function createRDFNodes(data, parentSubject = null) {
    const dataset = rdf.dataset();
    const subject = parentSubject || rdf.blankNode();
    data.forEach(item => {
        const predicate = rdf.namedNode(item.namespace + item.term);
        if (item.entries) {
            item.entries.forEach(entry => {
                const entrySubject = rdf.blankNode();
                dataset.add(rdf.quad(subject, predicate, entrySubject));
                const nestedDataset = createRDFNodes(Object.values(entry), entrySubject);
                dataset.addAll(nestedDataset);
            });
        } else {
            let object;
            if (item.type === 'LITERAL') {
                object = rdf.literal(item.value);
            } else if (item.type === 'URI') {
                object = rdf.namedNode(item.value);
            } else {
                object = rdf.blankNode();
            }
            dataset.add(rdf.quad(subject, predicate, object));
        }
    });
    return dataset;
}
function extractAllElementsData(form) {
    const elements = form.querySelectorAll('input, textarea');
    const data = Array.from(elements).map(extractElementData);
    const groupedData = data.reduce((acc, item) => {
        if (item.children) {
            const parentIndex = acc.findIndex(d => d.term === item.term);
            if (parentIndex !== -1) {
                acc[parentIndex].children = item.children;
            } else {
                acc.push(item);
            }
        } else {
            acc.push(item);
        }
        return acc;
    }, []);
    return groupedData;
}
function extractElementData(element) {
    const data = {};
    for (const attr of element.attributes) {
        if (attr.name.startsWith('data-')) {
            const key = attr.name.slice(5);
            try {
                data[key] = JSON.parse(attr.value);
            } catch {
                data[key] = attr.value;
            }
        }
    }
    data.value = element.value;
    if (element.tagName === 'FIELDSET') {
        data.entries = Array.from(element.querySelectorAll('.nested-entry'))
            .map(entry => {
                const entryData = {};
                entry.querySelectorAll('input, textarea').forEach(input => {
                    const inputData = extractElementData(input);
                    entryData[inputData.term] = inputData;
                });
                return entryData;
            });
    }
    return data;
}
function datasetToTurtle(dataset) {
    const writer = new N3Writer();
    let turtleString = '';
    writer.import(dataset.toStream())
        .on('data', (chunk) => { turtleString += chunk; })
        .on('end', () => {
            console.log('Serialization complete');
        });
    return turtleString;
}
function extract(document) {
    const form = document.querySelector('form');
    const data = extractAllElementsData(form);
    const dataset = createRDFNodes(data);
    return datasetToTurtle(dataset);
}
export { extract };

================
File: src/public/foaf-form.html
================
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Form</title>
        <script src="extractor.js" defer=""></script>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <header>
             <h1>Form</h1>
        </header>
        <main>
        </main>
        <footer>
            <p>2024</p>
        </footer>
        <form>
            <div class="form-group">
                <label>name</label>
            </div>
            <textarea data-term="name" data-type="LITERAL" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            <div class="form-group">
                <label>mbox</label>
            </div>
            <textarea data-term="mbox" data-type="URI" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            <div class="form-group">
                <label>homepage</label>
            </div>
            <textarea data-term="homepage" data-type="URI" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            <div class="form-group">
                <label>nick</label>
            </div>
            <textarea data-term="nick" data-type="LITERAL" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            <div class="form-group">
                <label>depiction</label>
            </div>
            <textarea data-term="depiction" data-type="URI" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            <div class="form-group">
                <label>interest</label>
            </div>
            <textarea data-term="interest" data-type="URI" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            <div class="form-group">
                <label>knows</label>
            </div>
            <fieldset data-term="knows" data-type="BNODE" data-namespace="http://xmlns.com/foaf/0.1/" data-children="{&quot;properties&quot;:[{&quot;term&quot;:&quot;name&quot;,&quot;type&quot;:&quot;LITERAL&quot;,&quot;namespace&quot;:&quot;http://xmlns.com/foaf/0.1/&quot;}],&quot;namespace&quot;:&quot;http://xmlns.com/foaf/0.1/&quot;,&quot;type&quot;:&quot;Person&quot;}">
                <legend>knows</legend>
                <div class="nested-entry">
                    <div class="form-group">
                        <label>name</label>
                        <textarea data-term="name" data-type="LITERAL" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
                    </div>
                    <button type="button">Remove</button>
                </div>
                <button type="button">Add knows</button>
            </fieldset>
            <fieldset>
                <legend>knows</legend>
                <div class="form-group">
                    <label>name</label>
                </div>
                <textarea data-term="name" data-type="LITERAL" data-namespace="http://xmlns.com/foaf/0.1/"></textarea>
            </fieldset>
            <div class="form-group">
                <label>maintainer-of</label>
            </div>
            <fieldset data-term="maintainer-of" data-type="BNODE" data-namespace="http://usefulinc.com/ns/doap#" data-children="{&quot;properties&quot;:[{&quot;term&quot;:&quot;homepage&quot;,&quot;type&quot;:&quot;URI&quot;,&quot;namespace&quot;:&quot;http://usefulinc.com/ns/doap#&quot;},{&quot;term&quot;:&quot;description&quot;,&quot;type&quot;:&quot;LITERAL&quot;,&quot;namespace&quot;:&quot;http://usefulinc.com/ns/doap#&quot;,&quot;subtype&quot;:&quot;LANG&quot;}],&quot;namespace&quot;:&quot;http://usefulinc.com/ns/doap#&quot;,&quot;type&quot;:&quot;Project&quot;}">
                <legend>maintainer-of</legend>
                <div class="nested-entry">
                    <div class="form-group">
                        <label>homepage</label>
                        <textarea data-term="homepage" data-type="URI" data-namespace="http://usefulinc.com/ns/doap#"></textarea>
                    </div>
                    <div class="form-group">
                        <label>description</label>
                        <textarea data-term="description" data-type="LITERAL" data-namespace="http://usefulinc.com/ns/doap#" data-subtype="LANG"></textarea>
                    </div>
                    <button type="button">Remove</button>
                </div>
                <button type="button">Add maintainer-of</button>
            </fieldset>
            <fieldset>
                <legend>maintainer-of</legend>
                <div class="form-group">
                    <label>homepage</label>
                </div>
                <textarea data-term="homepage" data-type="URI" data-namespace="http://usefulinc.com/ns/doap#"></textarea>
                <div class="form-group">
                    <label>description</label>
                </div>
                <textarea data-term="description" data-type="LITERAL" data-namespace="http://usefulinc.com/ns/doap#" data-subtype="LANG"></textarea>
            </fieldset>
            <div class="form-group">
                <label>taskStatus</label>
            </div>
            <input type="checkbox" data-term="taskStatus" data-type="LITERAL" data-namespace="http://purl.org/stuff/prj/" data-subtype="BOOLEAN">
            <div class="form-group">
                <label>priority</label>
            </div>
            <input type="number" data-term="priority" data-type="LITERAL" data-namespace="http://purl.org/stuff/prj/" data-subtype="INTEGER">
            <button type="button">Submit</button>
            <label for="output">Output</label>
            <textarea id="output" rows="10"></textarea>
        </form>
    </body>
</html>

================
File: src/public/styles.css
================

body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f4f4f4;
}
form {
    background-color: #fff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}
label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}
input[type="text"],
input[type="number"],
textarea {
    width: 100%;
    padding: 8px;
    margin-bottom: 15px;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-sizing: border-box;
}
input[type="checkbox"] {
    margin-bottom: 15px;
}
fieldset {
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 15px;
    margin-bottom: 20px;
}
legend {
    font-weight: bold;
    padding: 0 10px;
}
label {
    color: #2c3e50;
}
input:focus,
textarea:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
}
.form-group {
    margin-bottom: 15px;
}
.nested-entry {
    border: 1px solid #ddd;
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 4px;
}
fieldset button {
    margin-top: 10px;
}
@media (max-width: 600px) {
    body {
        padding: 10px;
    }
    form {
        padding: 15px;
    }
}

================
File: src/templates/foaf-template copy.ttl
================
# foaf-template.ttl sample for form-a-matic

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix prj: <http://purl.org/stuff/prj/> .
<#ROOT>
    a foaf:Person ;
    foaf:name "LITERAL" ;
    foaf:mbox <#URI> ;
    foaf:homepage <#URI> ;
    foaf:nick "LITERAL" ;
    foaf:depiction <#URI> ;
    foaf:interest <#URI> ;
    foaf:knows [
        a foaf:Person ;
        foaf:name "LITERAL"
    ] ;
    doap:maintainer-of
		[ a doap:Project ;
		    doap:homepage <#URI> ;
            doap:description "LITERAL:LANG"
        ];
    prj:taskStatus "LITERAL:BOOLEAN";
    prj:priority "LITERAL:INTEGER" .

================
File: src/templates/foaf-template.json
================
{
  "ROOT": {
    "properties": [
      {
        "term": "name",
        "type": "LITERAL",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "mbox",
        "type": "URI",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "homepage",
        "type": "URI",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "nick",
        "type": "LITERAL",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "depiction",
        "type": "URI",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "interest",
        "type": "URI",
        "namespace": "http://xmlns.com/foaf/0.1/"
      },
      {
        "term": "knows",
        "type": "BNODE",
        "namespace": "http://xmlns.com/foaf/0.1/",
        "children": {
          "properties": [
            {
              "term": "name",
              "type": "LITERAL",
              "namespace": "http://xmlns.com/foaf/0.1/"
            }
          ],
          "namespace": "http://xmlns.com/foaf/0.1/",
          "type": "Person"
        }
      },
      {
        "term": "maintainer-of",
        "type": "BNODE",
        "namespace": "http://usefulinc.com/ns/doap#",
        "children": {
          "properties": [
            {
              "term": "homepage",
              "type": "URI",
              "namespace": "http://usefulinc.com/ns/doap#"
            },
            {
              "term": "description",
              "type": "LITERAL",
              "namespace": "http://usefulinc.com/ns/doap#",
              "subtype": "LANG"
            }
          ],
          "namespace": "http://usefulinc.com/ns/doap#",
          "type": "Project"
        }
      },
      {
        "term": "taskStatus",
        "type": "LITERAL",
        "namespace": "http://purl.org/stuff/prj/",
        "subtype": "BOOLEAN"
      },
      {
        "term": "priority",
        "type": "LITERAL",
        "namespace": "http://purl.org/stuff/prj/",
        "subtype": "INTEGER"
      }
    ],
    "namespace": "http://xmlns.com/foaf/0.1/",
    "type": "Person"
  },
  "dataview": "http://purl.org/stuff/json-ldx",
  "transformation": "https://hyperdata.it/2004/json-ldx.js"
}

================
File: src/templates/foaf-template.ttl
================
# foaf-template.ttl sample for form-a-matic

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix prj: <http://purl.org/stuff/prj/> .
<#ROOT>
    a foaf:Person ;
    foaf:name "LITERAL" ;
    foaf:mbox <#URI> ;
    foaf:homepage <#URI> ;
    foaf:nick "LITERAL" ;
    foaf:depiction <#URI> ;
    foaf:interest <#URI> ;
    foaf:knows [
        a foaf:Person ;
        foaf:name "LITERAL"
    ] ;
    doap:maintainer-of
		[ a doap:Project ;
		    doap:homepage <#URI> ;
            doap:description "LITERAL:LANG"
        ];
    prj:taskStatus "LITERAL:BOOLEAN";
    prj:priority "LITERAL:INTEGER" .

================
File: src/templates/html-template.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form</title>
    <script src="extractor.js" defer></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Form</h1>
    </header>
    <main>
    </main>
    <footer>
        <p>2024</p>
    </footer>
</body>
</html>

================
File: src/tt-to-json.js
================

import { Readable } from 'stream';
import N3Parser from '@rdfjs/parser-n3';
class TurtleTemplateToJSON {
    constructor() {
        this.parser = new N3Parser();
        this.prefixes = {};
        this.result = {};
    }
    async parse(turtleString) {
        const input = Readable.from([turtleString]);
        const quads = [];
        for await (const quad of this.parser.import(input)) {
            quads.push(quad);
            if (quad.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
                this.prefixes[quad.object.value.split(':')[0]] = quad.object.value.split(':')[1];
            }
        }
        return quads;
    }
    processQuads(quads) {
        const rootQuad = quads.find(q => q.subject.value === '#ROOT');
        if (!rootQuad) throw new Error('No #ROOT subject found');
        this.result.ROOT = this.processNode(rootQuad.subject, quads)
        this.result.dataview = 'http://purl.org/stuff/json-ldx'
        this.result.transformation = 'https://hyperdata.it/2004/json-ldx.js'
        return this.result;
    }
    processNode(subject, quads) {
        const node = { properties: [] };
        const relevantQuads = quads.filter(q => q.subject.equals(subject));
        for (const quad of relevantQuads) {
            if (quad.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
                const { namespace, term } = this.splitURI(quad.object.value);
                node.namespace = namespace;
                node.type = term;
            } else {
                const property = this.processProperty(quad, quads);
                node.properties.push(property);
            }
        }
        return node;
    }
    processProperty(quad, quads) {
        const { namespace, term } = this.splitURI(quad.predicate.value);
        const markerValues = this.getMarkerType(quad.object)
        const property = {
            term: term,
            type: markerValues.type,
            namespace: namespace
        }
        if (markerValues.subtype) {
            property.subtype = markerValues.subtype
        }
        if (property.type === 'BNODE') {
            property.children = this.processNode(quad.object, quads);
        }
        return property;
    }
    getMarkerType(object) {
        const marker = this.splitMarker(object.value)
        if (object.termType === 'Literal') {
            return marker
        } else if (object.termType === 'NamedNode') {
            marker.type = 'URI'
        } else {
            marker.type = 'BNODE';
        }
        return marker
    }
    splitURI(uri) {
        const lastHashIndex = uri.lastIndexOf('#');
        const lastSlashIndex = uri.lastIndexOf('/');
        const splitIndex = Math.max(lastHashIndex, lastSlashIndex);
        if (splitIndex === -1) {
            return { namespace: '', term: uri };
        }
        // Split the URI
        const namespace = uri.substring(0, splitIndex + 1);
        const term = uri.substring(splitIndex + 1);
        return { namespace, term };
    }
    splitMarker(marker) {
        const [type, subtype] = marker.split(':');
        return {
            type,
            subtype: subtype || undefined
        };
    }
    async turtle2json(turtleString) {
        const quads = await this.parse(turtleString);
        return this.processQuads(quads);
    }
}
export default TurtleTemplateToJSON
