# Assessor Web Application Documentation

## Overview

The Assessor application is a web-based interactive assessment tool that presents users with a sequence of questions in a chat-like interface. It supports branching conversation flows, different question types (multiple choice, checkboxes, text input), and maintains session state for user progress.

## Architecture

The application follows a client-server architecture:

- **Frontend**: JavaScript-based UI with modular components for chat display and interaction
- **Backend**: Express.js server providing RESTful APIs for session management and response processing
- **Storage**: In-memory session storage (could be replaced with a database in production)

## Server-Side Components

### Server (`server.js`)

The main entry point for the application that initializes the Express server.

```javascript
const app = require('./app');
const logger = require('./utils/logger');
const PORT = process.env.PORT || 3000;

// Error handling for unhandled exceptions and rejections
process.on('uncaughtException', (error) => {
  logger.error('Uncaught exception:', error);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled rejection at:', promise, 'reason:', reason);
});

// Start server
app.listen(PORT, () => {
  logger.info(`Server running on port ${PORT}`);
  logger.info(`http://localhost:${PORT}`);
});
```

### Application (`app.js`)

Configures the Express application with middleware and defines API endpoints.

```javascript
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const { v4: uuidv4 } = require('uuid');
const path = require('path');

const app = express();

// Middleware
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, '..', 'public')));

// In-memory session storage
const sessions = new Map();

// Question data and API endpoints...

module.exports = app;
```

## HTTP API Protocol Specification

This section describes the protocol used between the client and server. The protocol is designed to be simple enough that alternative client or server implementations can be created while maintaining compatibility.

### Protocol Overview

- Communication happens over HTTP/HTTPS
- All requests and responses use JSON format
- Authentication is handled via session IDs generated by the server
- The server maintains session state
- Most errors are communicated with appropriate HTTP status codes and JSON error messages

### API Endpoints

#### Session Management

##### 1. Create Session

Creates a new user session and returns initial questions.

- **Endpoint**: `POST /api/session/create`
- **Request**: No body required
- **Headers**: 
  - `Content-Type: application/json`
- **Response**: 
  - Status: 200 OK
  - Body:
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "questions": [
      {
        "id": "1",
        "text": "Welcome to our assessment...",
        "options": [
          { "id": "1a", "text": "OK, let's begin" }
        ],
        "optionType": "button",
        "tagClass": "intro-section"
      },
      // More questions...
    ]
  }
  ```
- **Error Responses**:
  - 500 Internal Server Error: Server failed to create a session

##### 2. Get Session Status

Retrieves basic session information.

- **Endpoint**: `GET /api/session/:sessionId`
- **Request**: Session ID in URL path
- **Response**:
  - Status: 200 OK
  - Body:
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "startTime": 1711566451282,
    "currentQuestionIndex": 1,
    "responseCount": 1,
    "isComplete": false,
    "completedAt": null
  }
  ```
- **Error Responses**:
  - 404 Not Found: Session ID does not exist
  - 500 Internal Server Error: Server failed to retrieve session

##### 3. Get Full Session State

Retrieves the complete session state including all questions and responses.

- **Endpoint**: `GET /api/session/:sessionId/state`
- **Request**: Session ID in URL path
- **Response**:
  - Status: 200 OK
  - Body:
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "startTime": 1711566451282,
    "currentQuestionIndex": 1,
    "responses": [
      {
        "questionId": "1",
        "responseValue": "1a",
        "responseType": "option",
        "fieldName": "",
        "timestamp": "2025-03-26T20:27:31.282Z"
      }
    ],
    "questions": [/* Full question bank */],
    "isComplete": false,
    "completedAt": null
  }
  ```
- **Error Responses**:
  - 404 Not Found: Session ID does not exist
  - 500 Internal Server Error: Server failed to retrieve session state

##### 4. Ping Session

Keeps a session active and updates the last activity timestamp.

- **Endpoint**: `POST /api/session/:sessionId/ping`
- **Request**: Session ID in URL path
- **Response**:
  - Status: 200 OK
  - Body:
  ```json
  {
    "success": true,
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "lastActivity": 1711566481282
  }
  ```
- **Error Responses**:
  - 404 Not Found: Session ID does not exist
  - 401 Unauthorized: Session has expired
  - 500 Internal Server Error: Server error during ping operation

##### 5. Complete Session

Marks a session as complete.

- **Endpoint**: `POST /api/session/:sessionId/complete`
- **Request**: Session ID in URL path
- **Response**:
  - Status: 200 OK
  - Body:
  ```json
  {
    "success": true,
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "completedAt": "2025-03-26T21:15:42.123Z"
  }
  ```
- **Error Responses**:
  - 404 Not Found: Session ID does not exist
  - 500 Internal Server Error: Server error during completion

#### Response Handling

##### 1. Save Response

Saves a user's response to a question and determines the next question.

- **Endpoint**: `POST /api/response/save`
- **Headers**: 
  - `Content-Type: application/json`
- **Request Body**:
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9", 
    "questionId": "2",
    "responseValue": "2b",
    "responseType": "option",
    "fieldName": ""
  }
  ```
- **Response**:
  - Status: 200 OK
  - Body:
  ```json
  {
    "nextQuestionIndex": 2,
    "success": true
  }
  ```
- **Error Responses**:
  - 400 Bad Request: Invalid request format or missing required fields
  - 404 Not Found: Session ID does not exist
  - 500 Internal Server Error: Server error saving response

##### 2. Get Responses for Session

Retrieves all responses for a specific session.

- **Endpoint**: `GET /api/response/:sessionId`
- **Request**: Session ID in URL path
- **Response**:
  - Status: 200 OK
  - Body:
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "responses": [
      {
        "questionId": "1",
        "responseValue": "1a",
        "responseType": "option",
        "fieldName": "",
        "timestamp": "2025-03-26T20:27:31.282Z"
      },
      {
        "questionId": "2",
        "responseValue": "2b",
        "responseType": "option",
        "fieldName": "",
        "timestamp": "2025-03-26T20:28:45.619Z"
      }
    ]
  }
  ```
- **Error Responses**:
  - 404 Not Found: Session ID does not exist
  - 500 Internal Server Error: Server error retrieving responses

#### Results and Analysis

##### 1. Get Session Results

Retrieves assessment results and analysis.

- **Endpoint**: `GET /api/session/:sessionId/results`
- **Request**: Session ID in URL path
- **Response**:
  - Status: 200 OK
  - Body:
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "completedAt": "2025-03-26T21:15:42.123Z",
    "responseCount": 7,
    "analysisResults": [
      {
        "category": "Overall Health",
        "score": 75,
        "recommendations": [
          "Maintain your current health practices and stay active"
        ]
      }
    ]
  }
  ```
- **Error Responses**:
  - 400 Bad Request: Assessment not yet complete
  - 404 Not Found: Session ID does not exist
  - 500 Internal Server Error: Server error generating results

### Question and Response Schemas

#### Question Types

The server can provide different types of questions, each with its own schema:

##### 1. Button Options (Multiple Choice)

```json
{
  "id": "2",
  "text": "How would you rate your overall health?",
  "options": [
    { "id": "2a", "text": "Excellent" },
    { "id": "2b", "text": "Good" },
    { "id": "2c", "text": "Fair" },
    { "id": "2d", "text": "Poor" }
  ],
  "optionType": "button",
  "tagClass": "health-rating"
}
```

##### 2. Checkbox Options (Multiple Selection)

```json
{
  "id": "3b",
  "text": "What health concerns do you currently have?",
  "options": [
    { "id": "3b1", "text": "Chronic pain" },
    { "id": "3b2", "text": "Fatigue" },
    { "id": "3b3", "text": "Mental health" },
    { "id": "3b4", "text": "Other conditions" }
  ],
  "optionType": "checkbox",
  "buttonText": "Skip",
  "nextButtonText": "Continue",
  "tagClass": "health-concerns"
}
```

##### 3. Text Input

```json
{
  "id": "4",
  "text": "Would you like to tell us more about your health goals?",
  "isCustomInput": true,
  "inputType": "textarea",
  "fieldName": "health_goals",
  "placeholder": "Share your health goals here...",
  "buttonText": "Submit",
  "tagClass": "health-goals-section"
}
```

##### 4. URL Buttons (External Links)

```json
{
  "id": "6",
  "text": "Thank you for completing the assessment!",
  "options": [
    { "id": "6a", "text": "Learn more about our services", "url": "https://example.com/services" },
    { "id": "6b", "text": "No thanks, I'm done" }
  ],
  "optionType": "url-buttons",
  "tagClass": "completion-section"
}
```

#### Response Types

The client can send different types of responses:

##### 1. Option Selection Response

```json
{
  "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
  "questionId": "2",
  "responseValue": "2b",
  "responseType": "option",
  "fieldName": ""
}
```

##### 2. Checkbox Selection Response

```json
{
  "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
  "questionId": "3b",
  "responseValue": "3b1,3b3",
  "responseType": "checkbox",
  "fieldName": ""
}
```

##### 3. Text Input Response

```json
{
  "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
  "questionId": "4",
  "responseValue": "I want to improve my cardiovascular health and reduce stress.",
  "responseType": "text",
  "fieldName": "health_goals"
}
```

##### 4. Skip Response

```json
{
  "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
  "questionId": "3b",
  "responseValue": "",
  "responseType": "skip",
  "fieldName": ""
}
```

### Implementation Notes for Alternative Clients/Servers

#### For Clients Implementing this Protocol:

1. Begin by creating a session via `POST /api/session/create`
2. Store the session ID in local storage for recovery
3. Display questions to the user in sequence
4. Send user responses to the server via `POST /api/response/save`
5. Get the next question index from the response
6. Keep the session alive with periodic pings via `POST /api/session/:sessionId/ping`
7. Handle session expiration and recovery scenarios
8. Implement a way to display different question types (buttons, checkboxes, text inputs)
9. Complete the session when finished via `POST /api/session/:sessionId/complete`

#### For Servers Implementing this Protocol:

1. Implement all the specified endpoints
2. Generate and track session IDs (UUID v4 recommended)
3. Store session data (either in memory or a database)
4. Implement session timeout handling
5. Support branching logic based on user responses
6. Implement the question schema formats
7. Validate incoming response payloads
8. Generate appropriate error responses
9. Provide consistent response formats
10. Implement appropriate CORS headers for cross-origin requests

## HTTP API Endpoints

### Session Management

#### 1. Create Session

Creates a new user session and returns initial questions.

- **Endpoint**: `POST /api/session/create`
- **Request**: No body required
- **Response**: 
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "questions": [
      {
        "id": "1",
        "text": "Welcome to our assessment...",
        "options": [
          { "id": "1a", "text": "OK, let's begin" }
        ],
        "optionType": "button",
        "tagClass": "intro-section"
      },
      // More questions...
    ]
  }
  ```

#### 2. Get Session Status

Retrieves basic session information.

- **Endpoint**: `GET /api/session/:sessionId`
- **Request**: Session ID in URL path
- **Response**:
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "startTime": 1711566451282,
    "currentQuestionIndex": 1,
    "responseCount": 1,
    "isComplete": false,
    "completedAt": null
  }
  ```

#### 3. Get Full Session State

Retrieves the complete session state including all questions and responses.

- **Endpoint**: `GET /api/session/:sessionId/state`
- **Request**: Session ID in URL path
- **Response**:
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "startTime": 1711566451282,
    "currentQuestionIndex": 1,
    "responses": [
      {
        "questionId": "1",
        "responseValue": "1a",
        "responseType": "option",
        "fieldName": "",
        "timestamp": "2025-03-26T20:27:31.282Z"
      }
    ],
    "questions": [/* Full question bank */],
    "isComplete": false,
    "completedAt": null
  }
  ```

#### 4. Ping Session

Keeps a session active and updates the last activity timestamp.

- **Endpoint**: `POST /api/session/:sessionId/ping`
- **Request**: Session ID in URL path
- **Response**:
  ```json
  {
    "success": true,
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9",
    "lastActivity": 1711566481282
  }
  ```

### Response Handling

#### 1. Save Response

Saves a user's response to a question and determines the next question.

- **Endpoint**: `POST /api/response/save`
- **Request**:
  ```json
  {
    "sessionId": "01ce6479-5dc3-45c9-86ab-12b4a1eeaec9", 
    "questionId": "2",
    "responseValue": "2b",
    "responseType": "option",
    "fieldName": ""
  }
  ```
- **Response**:
  ```json
  {
    "nextQuestionIndex": 2,
    "success": true
  }
  ```

## Message Types and Formats

### Question Types

#### 1. Button Options

Multiple choice buttons:

```json
{
  "id": "2",
  "text": "How would you rate your overall health?",
  "options": [
    { "id": "2a", "text": "Excellent" },
    { "id": "2b", "text": "Good" },
    { "id": "2c", "text": "Fair" },
    { "id": "2d", "text": "Poor" }
  ],
  "optionType": "button",
  "tagClass": "health-rating"
}
```

#### 2. Checkbox Options

Multiple selection with checkboxes:

```json
{
  "id": "3b",
  "text": "What health concerns do you currently have?",
  "options": [
    { "id": "3b1", "text": "Chronic pain" },
    { "id": "3b2", "text": "Fatigue" },
    { "id": "3b3", "text": "Mental health" },
    { "id": "3b4", "text": "Other conditions" }
  ],
  "optionType": "checkbox",
  "buttonText": "Skip",
  "nextButtonText": "Continue",
  "tagClass": "health-concerns"
}
```

#### 3. Text Input

Free-text input fields:

```json
{
  "id": "4",
  "text": "Would you like to tell us more about your health goals?",
  "isCustomInput": true,
  "inputType": "textarea",
  "fieldName": "health_goals",
  "placeholder": "Share your health goals here...",
  "buttonText": "Submit",
  "tagClass": "health-goals-section"
}
```

### Response Types

1. **option**: Single selected option (buttons)
2. **checkbox**: Multiple selected options
3. **text**: Free-text input
4. **skip**: User skipped a question

## Client-Side Components

### Core Components

1. **EventBus** (`eventBus.js`): Handles communication between components
2. **SessionManager** (`sessionManager.js`): Manages session state and API communication
3. **ApiClient** (`api.js`): Handles HTTP requests to the backend

### UI Components

1. **ChatController** (`chat.js`): Manages the chat interface and user interactions
2. **MessageRenderer** (`messageRenderer.js`): Renders questions and responses in the chat UI
3. **NotificationManager** (`notifications.js`): Shows system notifications to users

## Event Flow

1. Application initializes and creates a new session or recovers an existing one
2. The first question is loaded and displayed to the user
3. User selects an option or enters text and submits
4. Response is sent to server and saved
5. Server determines next question based on branching logic
6. Next question is loaded and displayed
7. Process repeats until assessment is complete

## Session Lifecycle

1. **Creation**: New session created when user first loads the application
2. **Active**: Session maintained as user progresses through questions
3. **Timeout Warning**: Warning shown when session is about to expire due to inactivity
4. **Timeout**: Session times out after extended inactivity
5. **Reconnection**: User can reconnect to an active session
6. **Expiration**: Session fully expires after a longer period (e.g., 24 hours)
7. **Completion**: Session marked as complete when all questions are answered

## Branching Logic

The application supports conditional question flow based on user responses:

```javascript
// Example branching logic
if (questionId === '2') {
  // Health rating question
  if (responseValue === '2a' || responseValue === '2b') {
    // Excellent or Good health -> go to exercise question
    nextQuestionIndex = questionBank.findIndex(q => q.id === '3a');
  } else {
    // Fair or Poor health -> go to health concerns question
    nextQuestionIndex = questionBank.findIndex(q => q.id === '3b');
  }
}
```

## Error Handling

1. **API Errors**: Handled in the ApiClient with consistent error format
2. **Session Recovery**: Falls back to creating a new session if recovery fails
3. **UI Errors**: Shown to users via NotificationManager
4. **Input Validation**: Validates user inputs before submission

## Development Commands

```
npm start           - Start production server
npm run dev         - Start development server with hot reloading
npm run test        - Run test server on port 3001
npm run stop        - Stop the main server
npm run restart     - Restart the main server
npm run stop:test   - Stop the test server
npm run restart:test - Restart the test server
```

## Security Considerations

1. Session IDs are generated using UUID v4 for uniqueness
2. Session data stored server-side to prevent tampering
3. Input validation for all user inputs
4. Session expiration for inactive sessions