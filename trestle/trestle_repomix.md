This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-11T09:58:57.341Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------
User Provided Header:
-----------------------
Trestle Source Code

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
css/
  trestle.css
js/
  controller/
    TrestleController.js
  model/
    TrestleModel.js
  utils/
    EventBus.js
    utils.js
  view/
    TrestleView.js
  config.js
  main.js
index.html
jsdoc.json
package.json
README.md
vite.config.js

================================================================
Files
================================================================

================
File: css/trestle.css
================
:root {
    --primary-color: #444;
    --secondary-color: #666;
    --highlight-color: #eee;
    --background-color: #fff;
    --border-color: #ddd;
    --selected-bg: #ffa;
    --highlight-bg: #f5f5f5;
    --card-header-bg: #666;
    --card-header-color: #fff;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    background-color: var(--highlight-color);
    font-size: 16px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

body {
    height: 100vh;
    display: flex;
    flex-direction: column;
}


#header-outer {
    background-color: var(--primary-color);
    color: #fff;
    text-align: center;
    padding: 10px;
    border-radius: 0 0 5px 5px;
}

#header {
    font-size: 1.5rem;
    font-weight: bold;
}


#menu-box {
    position: fixed;
    top: 70px;
    left: 16px;
    text-align: left;
    background-color: var(--secondary-color);
    width: 140px;
    border-radius: 10px;
    margin: 16px 0px 0px 16px;
    padding: 5px;
    border: 2px solid #fff;
    box-shadow: 1px 1px 1px #222;
    z-index: 10;
}

.toolbar ul {
    list-style-type: none;
    margin: 0;
    padding: 0.2em 0;
    background-color: var(--secondary-color);
    color: #fff;
}

.toolbar li {
    text-align: center;
    margin: 5px;
}

.toolbar button {
    width: 130px;
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 5px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s;
}

.toolbar button:hover {
    background-color: #e0e0e0;
}


#container {
    position: fixed;
    top: 80px;
    left: 200px;
    right: 0;
    bottom: 0;
    overflow-y: auto;
    padding: 2em;
    background-color: var(--background-color);
    box-shadow: 1px 1px 4px #444;
    z-index: 1;
}

.page {
    margin: 15px auto;
    max-width: 800px;
}


#trestle {
    display: block;
    margin: 0;
    list-style: none;
    user-select: none;
}

#trestle ul {
    font-size: 1em;
    list-style: none;
    padding-left: 20px;
}

#trestle li {
    display: block;
    position: relative;
    margin: 2px 0;
}


.ts-entry {
    position: relative;
    display: flex;
    align-items: center;
    min-height: 32px;
    padding: 4px 0;
    background: var(--background-color);
    border-radius: 4px;
}

.ts-entry:hover {
    background-color: var(--highlight-bg);
}

.ts-title {
    cursor: text;
    outline: none;
    padding: 0 4px;
    line-height: 1.5;
    flex-grow: 1;
}

.ts-title:focus {
    background-color: rgba(255, 255, 255, 0.8);
    border-bottom: 1px solid #ccc;
}


.ts-handle {
    display: none;
    cursor: move;
    color: #888;
    padding: 0 10px;
    font-size: 16px;
}

.ts-entry:hover .ts-handle {
    display: block;
}


.ts-actions {
    display: none;
    padding: 0 4px;
}

.ts-entry:hover .ts-actions {
    display: flex;
}

.ts-actions button {
    background: none;
    border: none;
    cursor: pointer;
    margin: 0 2px;
    padding: 2px;
    font-size: 14px;
}

.ts-actions button:hover {
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
}


.ts-expander {
    cursor: pointer;
    width: 20px;
    height: 20px;
    background: none;
    border: none;
    position: relative;
    margin-right: 4px;
}

.ts-expander::before {
    content: "▼";
    font-size: 10px;
    color: #888;
}

.ts-closed>.ts-entry>.ts-expander::before {
    content: "▶";
}

.ts-closed>ul {
    display: none;
}


.ts-highlight {
    background-color: var(--highlight-bg);
}

.ts-selected {
    background-color: var(--selected-bg);
}


.ts-dragging {
    opacity: 0.5;
}

.dropzone {
    height: 8px;
    background-color: transparent;
    transition: background-color 0.2s;
}

.dropzone.active {
    background-color: #dfd;
    height: 10px;
}


#card {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 350px;
    background-color: white;
    border: 1px solid var(--border-color);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    z-index: 1000;
}

#card-title {
    padding: 10px;
    background-color: var(--card-header-bg);
    color: var(--card-header-color);
    border-radius: 8px 8px 0 0;
    font-weight: bold;
    word-break: break-all;
}

#card-content {
    padding: 10px;
}

#card-description {
    width: 100%;
    min-height: 100px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    resize: vertical;
}

#card-nid,
#card-date {
    font-size: 0.8em;
    color: #666;
    padding: 5px 10px;
}

#card-close {
    margin: 10px;
    padding: 5px 10px;
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    float: right;
}


.hidden {
    display: none !important;
}

#shortcuts-text {
    position: fixed;
    top: 200px;
    left: 10px;
    padding: 10px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    width: 200px;
}


.drag-placeholder {
    border: 1px dashed #aaa;
    background-color: #f9f9f9;
    height: 30px;
    margin: 4px 0;
    border-radius: 4px;
}


[contenteditable="true"]:focus {
    background-color: white;
    padding: 2px 4px;
    outline: 1px solid #ddd;
}


.text-box {
    background-color: white;
    border-radius: 10px;
    padding: 10px;
    box-shadow: 1px 1px 1px #444;
}

================
File: js/controller/TrestleController.js
================
export class TrestleController {





    constructor(model, view, eventBus) {
        this.model = model
        this.view = view
        this.eventBus = eventBus


        this.setupEventHandlers()
    }




    initialize() {
        this.model.initialize()
    }




    setupEventHandlers() {

        this.eventBus.subscribe('view:addChild', this.handleAddChild.bind(this))
        this.eventBus.subscribe('view:addSibling', this.handleAddSibling.bind(this))
        this.eventBus.subscribe('view:updateNode', this.handleUpdateNode.bind(this))
        this.eventBus.subscribe('view:deleteNode', this.handleDeleteNode.bind(this))
        this.eventBus.subscribe('view:moveNode', this.handleMoveNode.bind(this))
        this.eventBus.subscribe('view:indentNode', this.handleIndentNode.bind(this))
        this.eventBus.subscribe('view:outdentNode', this.handleOutdentNode.bind(this))
        this.eventBus.subscribe('view:getNodeData', this.handleGetNodeData.bind(this))
    }




    async saveData() {
        const success = await this.model.saveData()
        if (success) {
            alert('Data saved successfully')
        } else {
            alert('Failed to save data')
        }
    }




    addRootItem() {
        const rootNode = this.model.getRootNode()
        if (!rootNode) return


        const node = this.model.addNode(rootNode.id, '', rootNode.children.length)
        this.eventBus.publish('node:added', {
            node,
            parentId: 'trestle-root'
        })
    }






    updateNodeDescription(nodeId, description) {
        this.model.updateNodeDescription(nodeId, description)
    }







    handleAddChild(data) {
        const { parentId } = data
        const parent = this.model.getNode(parentId)
        if (!parent) return

        const childIndex = parent.children ? parent.children.length : 0
        const node = this.model.addNode(parentId, '', childIndex)

        this.eventBus.publish('node:added', {
            node,
            parentId
        })
    }





    handleAddSibling(data) {
        const { nodeId } = data
        const node = this.model.getNode(nodeId)
        if (!node) return


        const parentId = node.parent
        const parent = this.model.getNode(parentId)
        if (!parent) return


        const siblingIndex = parent.children.indexOf(nodeId)
        if (siblingIndex === -1) return



        const newNode = this.model.addNode(parentId, '', siblingIndex + 1)
        //    const newNode = this.model.addNode(parentId, 'New Item', siblingIndex + 1)
        this.eventBus.publish('node:added', {
            node: newNode,
            parentId
        })
    }





    handleUpdateNode(data) {
        const { nodeId, properties } = data

        this.model.updateNode(nodeId, properties)

        this.eventBus.publish('node:updated', {
            nodeId,
            properties
        })
    }





    handleDeleteNode(data) {
        const { nodeId } = data

        this.model.deleteNode(nodeId)

        this.eventBus.publish('node:deleted', {
            nodeId
        })
    }





    handleMoveNode(data) {
        const { nodeId, newParentId, newIndex } = data

        this.model.moveNode(nodeId, newParentId, newIndex)


    }





    handleIndentNode(data) {
        const { nodeId } = data
        const node = this.model.getNode(nodeId)
        if (!node || !node.parent) return

        const parent = this.model.getNode(node.parent)
        if (!parent || !parent.children) return


        const index = parent.children.indexOf(nodeId)
        if (index <= 0) return


        const newParentId = parent.children[index - 1]
        const newParent = this.model.getNode(newParentId)
        if (!newParent) return


        this.model.moveNode(nodeId, newParentId, newParent.children ? newParent.children.length : 0)


        this.eventBus.publish('view:nodeIndented', {
            nodeId,
            newParentId
        })
    }





    handleOutdentNode(data) {
        const { nodeId } = data
        const node = this.model.getNode(nodeId)
        if (!node || !node.parent) return

        const parent = this.model.getNode(node.parent)
        if (!parent || !parent.parent) return

        const grandparentId = parent.parent
        const grandparent = this.model.getNode(grandparentId)
        if (!grandparent) return


        const parentIndex = grandparent.children.indexOf(parent.id)
        if (parentIndex === -1) return


        this.model.moveNode(nodeId, grandparentId, parentIndex + 1)


        this.eventBus.publish('view:nodeOutdented', {
            nodeId,
            newParentId: grandparentId
        })
    }





    handleGetNodeData(data) {
        const { nodeId, callback } = data

        const node = this.model.getNode(nodeId)
        if (node && callback) {
            callback(node)
        }
    }
}

================
File: js/model/TrestleModel.js
================
import { Config } from '../config.js'
import { generateID, generateDate } from '../utils/utils.js'

export class TrestleModel {





    constructor(endpoint, baseUri, eventBus) {
        this.endpoint = endpoint
        this.baseUri = baseUri
        this.eventBus = eventBus
        this.rootId = null
        this.nodes = new Map()


        this.eventBus.subscribe('node:updated', this.handleNodeUpdate.bind(this))
        this.eventBus.subscribe('node:moved', this.handleNodeMove.bind(this))
        this.eventBus.subscribe('node:deleted', this.handleNodeDelete.bind(this))
    }




    async initialize() {
        try {
            await this.loadData()
            this.eventBus.publish('model:loaded', { nodes: Array.from(this.nodes.values()) })
        } catch (error) {
            console.error('Failed to initialize model:', error)

            this.createEmptyModel()
        }
    }




    createEmptyModel() {
        const rootId = this.generateNodeId('root')
        this.rootId = rootId


        this.nodes.set(rootId, {
            id: rootId,
            type: 'RootNode',
            children: []
        })

        this.eventBus.publish('model:created', {
            rootId: this.rootId,
            nodes: Array.from(this.nodes.values())
        })
    }






    generateNodeId(prefix = 'nid') {
        return `${prefix}-${generateID()}`
    }




    async loadData() {
        try {
            const fURL = `${this.endpoint}?query=${encodeURIComponent(this.buildLoadQuery())}`
            console.log(`fURL = ${decodeURI(fURL)}`)
            const response = await fetch(fURL, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            })

            if (!response.ok) {
                throw new Error(`SPARQL query failed: ${response.statusText}`)
            }

            const data = await response.json()
            console.log(`data = ${JSON.stringify(data)}`)
            this.processLoadedData(data)

            return true
        } catch (error) {
            console.error('Error loading data:', error)
            throw error
        }
    }




    buildLoadQuery() {
        return `
            PREFIX dc: <${Config.PREFIXES.dc}>
            PREFIX ts: <${Config.PREFIXES.ts}>

            SELECT ?node ?type ?title ?created ?index ?parent WHERE {
                ?node a ?type .
                OPTIONAL { ?node dc:title ?title } .
                OPTIONAL { ?node dc:created ?created } .
                OPTIONAL { ?node ts:index ?index } .
                OPTIONAL { ?node ts:parent ?parent } .
             #   FILTER(STRSTARTS(STR(?type), "${Config.PREFIXES.ts}"))
            }
        `
    }





    processLoadedData(data) {

        this.nodes.clear()
        this.rootId = null


        const nodesMap = new Map()


        for (const binding of data.results.bindings) {
            const nodeUri = binding.node.value
            const nodeId = this.extractLocalId(nodeUri)
            const type = this.extractLocalType(binding.type.value)


            let node = nodesMap.get(nodeId) || { id: nodeId, children: [] }
            node.type = type

            if (binding.title) {
                node.title = binding.title.value
            }

            if (binding.created) {
                node.created = binding.created.value
            }

            if (binding.index) {
                node.index = parseInt(binding.index.value, 10)
            }

            if (binding.parent) {
                node.parent = this.extractLocalId(binding.parent.value)
            }


            if (type === 'RootNode') {
                this.rootId = nodeId
            }

            nodesMap.set(nodeId, node)
        }


        for (const [id, node] of nodesMap.entries()) {
            if (node.parent) {
                const parentNode = nodesMap.get(node.parent)
                if (parentNode) {
                    if (!parentNode.children) {
                        parentNode.children = []
                    }
                    parentNode.children.push(id)
                }
            }
        }


        for (const node of nodesMap.values()) {
            if (node.children && node.children.length > 0) {
                node.children.sort((a, b) => {
                    const nodeA = nodesMap.get(a)
                    const nodeB = nodesMap.get(b)
                    return (nodeA.index || 0) - (nodeB.index || 0)
                })
            }
        }


        this.nodes = nodesMap
    }






    extractLocalId(uri) {
        const parts = uri.split('/')
        return parts[parts.length - 1]
    }






    extractLocalType(uri) {
        const parts = uri.split('/')
        return parts[parts.length - 1]
    }








    addNode(parentId, title, index) {
        const nodeId = this.generateNodeId()
        const now = generateDate()

        const newNode = {
            id: nodeId,
            type: 'Node',

            title: title || '',
            created: now,
            parent: parentId,
            index: index,
            children: []
        }

        // Add to model
        this.nodes.set(nodeId, newNode)

        // Update parent's children
        const parentNode = this.nodes.get(parentId)
        if (parentNode) {
            if (!parentNode.children) {
                parentNode.children = []
            }

            if (typeof index === 'number') {
                parentNode.children.splice(index, 0, nodeId)


                this.updateChildIndices(parentNode)
            } else {

                newNode.index = parentNode.children.length
                parentNode.children.push(nodeId)
            }
        }

        return newNode
    }





    updateChildIndices(parentNode) {
        if (parentNode.children) {
            parentNode.children.forEach((childId, index) => {
                const child = this.nodes.get(childId)
                if (child) {
                    child.index = index
                }
            })
        }
    }







    moveNode(nodeId, newParentId, newIndex) {
        const node = this.nodes.get(nodeId)
        if (!node) return

        const oldParentId = node.parent
        const oldParent = this.nodes.get(oldParentId)


        if (oldParent && oldParent.children) {
            const oldIndex = oldParent.children.indexOf(nodeId)
            if (oldIndex !== -1) {
                oldParent.children.splice(oldIndex, 1)
                this.updateChildIndices(oldParent)
            }
        }


        const newParent = this.nodes.get(newParentId)
        if (newParent) {
            if (!newParent.children) {
                newParent.children = []
            }

            if (typeof newIndex === 'number') {
                newParent.children.splice(newIndex, 0, nodeId)
            } else {
                newParent.children.push(nodeId)
                newIndex = newParent.children.length - 1
            }


            node.parent = newParentId
            node.index = newIndex


            this.updateChildIndices(newParent)
        }
    }





    deleteNode(nodeId) {
        const node = this.nodes.get(nodeId)
        if (!node) return


        if (node.children && node.children.length > 0) {

            const childrenToDelete = [...node.children]
            for (const childId of childrenToDelete) {
                this.deleteNode(childId)
            }
        }


        const parentId = node.parent
        if (parentId) {
            const parent = this.nodes.get(parentId)
            if (parent && parent.children) {
                const index = parent.children.indexOf(nodeId)
                if (index !== -1) {
                    parent.children.splice(index, 1)
                    this.updateChildIndices(parent)
                }
            }
        }


        this.nodes.delete(nodeId)
    }






    updateNode(nodeId, properties) {
        const node = this.nodes.get(nodeId)
        if (!node) return


        Object.assign(node, properties)
    }






    updateNodeDescription(nodeId, description) {
        const node = this.nodes.get(nodeId)
        if (!node) return

        node.description = description
    }






    getNode(nodeId) {
        return this.nodes.get(nodeId)
    }





    getAllNodes() {
        return Array.from(this.nodes.values())
    }





    getRootNode() {
        return this.nodes.get(this.rootId)
    }





    toTurtle() {
        let turtle = `@prefix dc: <${Config.PREFIXES.dc}> .\n`
        turtle += `@prefix ts: <${Config.PREFIXES.ts}> .\n\n`


        const rootNode = this.nodes.get(this.rootId)
        if (rootNode) {
            turtle += `<${this.baseUri}${rootNode.id}> a ts:RootNode .\n`
        }


        for (const [id, node] of this.nodes.entries()) {

            if (id === this.rootId) continue

            if (node.type === 'Node') {
                turtle += `<${this.baseUri}${node.id}> a ts:Node;\n`


                if (node.title) {
                    turtle += `   dc:title "${this.escapeTurtle(node.title)}" ;\n`
                }


                if (node.created) {
                    turtle += `   dc:created "${node.created}" ;\n`
                }


                turtle += `   ts:index "${node.index}" ;\n`


                if (node.parent) {
                    turtle += `   ts:parent <${this.baseUri}${node.parent}> .\n`
                } else {

                    turtle += `   ts:parent <${this.baseUri}${this.rootId}> .\n`
                }


                if (node.description) {
                    turtle += `<${this.baseUri}${node.id}> dc:description """${this.escapeTurtle(node.description)}""" .\n`
                }
            }
        }

        return turtle
    }






    escapeTurtle(text) {
        if (!text) return ''
        return text
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t')
    }





    async saveData() {
        try {
            const turtle = this.toTurtle()

            const response = await fetch(this.endpoint, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'text/turtle'
                },
                body: turtle
            })

            if (!response.ok) {
                throw new Error(`Failed to save data: ${response.statusText}`)
            }

            return true
        } catch (error) {
            console.error('Error saving data:', error)
            this.eventBus.publish('model:error', { message: 'Failed to save data', error })
            return false
        }
    }







    handleNodeUpdate(data) {
        const { nodeId, properties } = data
        this.updateNode(nodeId, properties)
    }





    handleNodeMove(data) {
        const { nodeId, newParentId, newIndex } = data
        this.moveNode(nodeId, newParentId, newIndex)
    }





    handleNodeDelete(data) {
        const { nodeId } = data
        this.deleteNode(nodeId)
    }
}

================
File: js/utils/EventBus.js
================
export class EventBus {
    constructor() {
        this.subscribers = new Map();
    }







    subscribe(event, callback) {
        if (!this.subscribers.has(event)) {
            this.subscribers.set(event, []);
        }

        const callbacks = this.subscribers.get(event);
        callbacks.push(callback);


        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1) {
                callbacks.splice(index, 1);
            }
        };
    }






    publish(event, data = {}) {
        if (!this.subscribers.has(event)) {
            return;
        }

        const callbacks = this.subscribers.get(event);
        callbacks.forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`Error in event handler for ${event}:`, error);
            }
        });
    }





    unsubscribeAll(event) {
        if (event) {
            this.subscribers.delete(event);
        } else {
            this.subscribers.clear();
        }
    }
}

================
File: js/utils/utils.js
================
export function generateID() {
    const now = new Date()
    const timestamp = formatDate(now, "yyyy-mm-dd-HH-MM-ss-l")
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0')
    return `${timestamp}-${random}`
}





export function generateDate() {
    return new Date().toISOString()
}








export function formatDate(date, mask, utc = true) {
    const token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g
    const timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g
    const timezoneClip = /[^-+\dA-Z]/g

    const pad = (val, len) => {
        val = String(val)
        len = len || 2
        while (val.length < len) val = "0" + val
        return val
    }


    if (arguments.length === 1 && Object.prototype.toString.call(date) === "[object String]" && !/\d/.test(date)) {
        mask = date
        date = undefined
    }


    date = date ? new Date(date) : new Date()
    if (isNaN(date)) throw SyntaxError("invalid date")

    mask = String(masks[mask] || mask || masks["default"])


    if (mask.slice(0, 4) === "UTC:") {
        mask = mask.slice(4)
        utc = true
    }

    const _ = utc ? "getUTC" : "get"
    const d = date[_ + "Date"]()
    const D = date[_ + "Day"]()
    const m = date[_ + "Month"]()
    const y = date[_ + "FullYear"]()
    const H = date[_ + "Hours"]()
    const M = date[_ + "Minutes"]()
    const s = date[_ + "Seconds"]()
    const L = date[_ + "Milliseconds"]()
    const o = utc ? 0 : date.getTimezoneOffset()

    const flags = {
        d: d,
        dd: pad(d),
        ddd: dayNames[D],
        dddd: dayNames[D + 7],
        m: m + 1,
        mm: pad(m + 1),
        mmm: monthNames[m],
        mmmm: monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: pad(H % 12 || 12),
        H: H,
        HH: pad(H),
        M: M,
        MM: pad(M),
        s: s,
        ss: pad(s),
        l: pad(L, 3),
        L: pad(L > 99 ? Math.round(L / 10) : L),
        t: H < 12 ? "a" : "p",
        tt: H < 12 ? "am" : "pm",
        T: H < 12 ? "A" : "P",
        TT: H < 12 ? "AM" : "PM",
        Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
        o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
    }

    return mask.replace(token, function ($0) {
        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)
    })
}


const masks = {
    "default": "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
}


const dayNames = [
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
]

const monthNames = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
]






export function escapeHtml(text) {
    if (!text) return ''

    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
}






export function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj
    }

    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item))
    }

    const cloned = {}
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            cloned[key] = deepClone(obj[key])
        }
    }

    return cloned
}

================
File: js/view/TrestleView.js
================
export class TrestleView {




    constructor(rootElement, eventBus) {

        this.rootElement = rootElement
        this.eventBus = eventBus
        this.template = document.getElementById('entry-template')
        this.nodeElements = new Map()
        this.selectedNodeId = null
        this.draggedNodeId = null
        this.dragTarget = null


        this.eventBus.subscribe('model:loaded', this.renderTree.bind(this))
        this.eventBus.subscribe('model:created', this.renderTree.bind(this))
        this.eventBus.subscribe('node:added', this.handleNodeAdded.bind(this))
        this.eventBus.subscribe('node:updated', this.handleNodeUpdated.bind(this))
        this.eventBus.subscribe('node:deleted', this.handleNodeDeleted.bind(this))
    }





    renderTree(data) {

        this.rootElement.innerHTML = ''
        this.nodeElements.clear()

        const rootNode = data.nodes.find(node => node.type === 'RootNode')
        if (!rootNode) {
            console.error('No root node found')

            return
        }


        const tree = this.buildTreeStructure(data.nodes, rootNode.id)


        const rootUl = document.createElement('ul')
        rootUl.className = 'ts-root'
        this.rootElement.appendChild(rootUl)


        for (const childId of tree.children || []) {
            this.renderNode(childId, rootUl, tree.nodes)
        }


        this.setupEventListeners()


        this.initDragAndDrop()
    }







    buildTreeStructure(nodes, rootId) {
        const nodesMap = new Map()


        for (const node of nodes) {
            nodesMap.set(node.id, { ...node })
        }


        for (const node of nodesMap.values()) {
            if (node.children) {

                node.children = node.children.filter(childId => nodesMap.has(childId))
            } else {
                node.children = []
            }
        }

        return {
            rootId,
            nodes: nodesMap
        }
    }








    renderNode(nodeId, parentElement, nodesMap) {
        const node = nodesMap.get(nodeId)
        if (!node) return null


        const li = document.createElement('li')
        li.dataset.nodeId = nodeId


        const dropzone = document.createElement('div')
        dropzone.className = 'dropzone'
        li.appendChild(dropzone)


        const entry = this.template.content.cloneNode(true).querySelector('.ts-entry')
        entry.id = nodeId


        const titleElement = entry.querySelector('.ts-title')
        titleElement.textContent = node.title || ''

        // Set created date (hidden)
        const dateElement = entry.querySelector('.date')
        dateElement.textContent = node.created || ''

        // Append entry to list item
        li.appendChild(entry)

        // Add to nodeElements map
        this.nodeElements.set(nodeId, li)

        // Render children if any
        if (node.children && node.children.length > 0) {
            const ul = document.createElement('ul')
            li.appendChild(ul)
            li.classList.add('ts-open')

            for (const childId of node.children) {
                this.renderNode(childId, ul, nodesMap)
            }
        } else {
            li.classList.add('ts-closed')
        }


        parentElement.appendChild(li)

        return li
    }




    setupEventListeners() {

        this.rootElement.addEventListener('click', this.handleClick.bind(this))
        this.rootElement.addEventListener('dblclick', this.handleDblClick.bind(this))
        this.rootElement.addEventListener('keydown', this.handleKeyDown.bind(this))


        this.rootElement.addEventListener('focus', this.handleFocus.bind(this), true)
        this.rootElement.addEventListener('blur', this.handleBlur.bind(this), true)
    }





    handleClick(event) {
        const target = event.target


        if (target.classList.contains('ts-expander')) {
            const li = target.closest('li')
            li.classList.toggle('ts-closed')
            li.classList.toggle('ts-open')
            event.stopPropagation()
            return
        }


        if (target.classList.contains('ts-card')) {
            this.showCard(target.closest('.ts-entry').id)
            event.stopPropagation()
            return
        }

        if (target.classList.contains('ts-addChild')) {
            const entryId = target.closest('.ts-entry').id
            this.eventBus.publish('view:addChild', { parentId: entryId })
            event.stopPropagation()
            return
        }

        if (target.classList.contains('ts-delete')) {
            const entryId = target.closest('.ts-entry').id
            if (confirm('Are you sure you want to delete this item and all its children?')) {
                this.eventBus.publish('view:deleteNode', { nodeId: entryId })
            }
            event.stopPropagation()
            return
        }


        if (target.classList.contains('ts-entry') || target.classList.contains('ts-title')) {
            const entry = target.classList.contains('ts-entry') ? target : target.closest('.ts-entry')
            this.selectNode(entry.id)
            event.stopPropagation()
            return
        }
    }





    handleDblClick(event) {
        const target = event.target


        if (target.classList.contains('ts-title')) {
            target.contentEditable = true
            target.focus()


            const range = document.createRange()
            range.selectNodeContents(target)
            const selection = window.getSelection()
            selection.removeAllRanges()
            selection.addRange(range)

            event.stopPropagation()
        }
    }





    handleKeyDown(event) {

        if (!event.target.isContentEditable) return

        const entry = event.target.closest('.ts-entry')
        if (!entry) return

        switch (event.key) {
            case 'Enter':
                if (!event.shiftKey) {

                    event.preventDefault()


                    event.target.contentEditable = false


                    const nodeId = entry.id
                    const newTitle = event.target.textContent.trim()
                    this.eventBus.publish('view:updateNode', { nodeId, properties: { title: newTitle } })


                    this.eventBus.publish('view:addSibling', { nodeId })
                }
                break

            case 'Tab':
                event.preventDefault()
                if (event.shiftKey) {

                    this.eventBus.publish('view:outdentNode', { nodeId: entry.id })
                } else {

                    this.eventBus.publish('view:indentNode', { nodeId: entry.id })
                }
                break

            case 'Escape':

                event.preventDefault()



                event.target.contentEditable = true
                this.selectNode(entry.id)
                break

            case 'ArrowUp':

                event.preventDefault()
                this.navigateUp(entry.id)
                break

            case 'ArrowDown':

                event.preventDefault()
                this.navigateDown(entry.id)
                break
        }
    }





    handleFocus(event) {
        if (event.target.classList.contains('ts-title')) {
            const entry = event.target.closest('.ts-entry')
            this.selectNode(entry.id)
        }
    }





    handleBlur(event) {
        if (event.target.classList.contains('ts-title') && event.target.isContentEditable) {



            const entry = event.target.closest('.ts-entry')
            const nodeId = entry.id
            const newTitle = event.target.textContent.trim()

            this.eventBus.publish('view:updateNode', { nodeId, properties: { title: newTitle } })
        }
    }




    initDragAndDrop() {

        const handles = this.rootElement.querySelectorAll('.ts-handle')
        handles.forEach(handle => {
            handle.addEventListener('mousedown', this.handleDragStart.bind(this))
            handle.setAttribute('draggable', 'true')
            handle.addEventListener('dragstart', this.handleDragStart.bind(this))
        })


        const dropzones = this.rootElement.querySelectorAll('.dropzone')
        dropzones.forEach(dropzone => {
            dropzone.addEventListener('dragover', this.handleDragOver.bind(this))
            dropzone.addEventListener('dragleave', this.handleDragLeave.bind(this))
            dropzone.addEventListener('drop', this.handleDrop.bind(this))
        })


        const items = this.rootElement.querySelectorAll('li')
        items.forEach(item => {
            item.addEventListener('dragenter', this.handleDragEnter.bind(this))
        })
    }





    handleDragStart(event) {
        const entry = event.target.closest('.ts-entry')
        if (!entry) return


        this.draggedNodeId = entry.id


        if (event.dataTransfer) {
            event.dataTransfer.setData('text/plain', entry.id)
            event.dataTransfer.effectAllowed = 'move'


            const dragImage = entry.cloneNode(true)
            dragImage.style.width = `${entry.offsetWidth}px`
            dragImage.style.opacity = '0.7'
            document.body.appendChild(dragImage)
            event.dataTransfer.setDragImage(dragImage, 10, 10)


            setTimeout(() => {
                document.body.removeChild(dragImage)
            }, 0)
        }


        entry.classList.add('ts-dragging')


        this.selectNode(entry.id)
    }





    handleDragOver(event) {

        event.preventDefault()

        if (!this.draggedNodeId) return


        event.target.classList.add('active')


        event.dataTransfer.dropEffect = 'move'
    }





    handleDragLeave(event) {

        event.target.classList.remove('active')
    }





    handleDragEnter(event) {
        const li = event.target.closest('li')
        if (!li || !this.draggedNodeId) return


        this.dragTarget = li


        li.classList.add('ts-highlight')


        if (this.dragEnterTimer) {
            clearTimeout(this.dragEnterTimer)
        }


        this.dragEnterTimer = setTimeout(() => {
            if (li.classList.contains('ts-closed')) {
                li.classList.remove('ts-closed')
                li.classList.add('ts-open')
            }
        }, 700)
    }





    handleDrop(event) {

        event.preventDefault()


        const dropzone = event.target
        dropzone.classList.remove('active')

        if (!this.draggedNodeId) return

        const draggedLi = this.nodeElements.get(this.draggedNodeId)
        if (!draggedLi) return


        const targetLi = dropzone.closest('li')
        if (!targetLi) return


        if (draggedLi.contains(targetLi)) {
            console.warn('Cannot drop onto a child element')
            return
        }


        const parentUl = targetLi.parentElement


        const isDropAfter = dropzone === targetLi.querySelector('.dropzone')

        let newParentId
        let newIndex

        if (isDropAfter) {

            newParentId = targetLi.parentElement.closest('li')?.dataset.nodeId || 'trestle-root'


            const siblings = Array.from(parentUl.children)
            newIndex = siblings.indexOf(targetLi)
        } else {

            newParentId = targetLi.dataset.nodeId


            let childUl = targetLi.querySelector('ul')
            if (!childUl) {
                childUl = document.createElement('ul')
                targetLi.appendChild(childUl)
                targetLi.classList.remove('ts-closed')
                targetLi.classList.add('ts-open')
            }


            newIndex = childUl.children.length
        }


        this.eventBus.publish('view:moveNode', {
            nodeId: this.draggedNodeId,
            newParentId: newParentId,
            newIndex: newIndex
        })


        this.draggedNodeId = null
        draggedLi.classList.remove('ts-dragging')


        document.querySelectorAll('.ts-highlight').forEach(el => {
            el.classList.remove('ts-highlight')
        })
    }





    selectNode(nodeId) {

        if (this.selectedNodeId) {
            const prevSelected = document.getElementById(this.selectedNodeId)
            if (prevSelected) {
                prevSelected.classList.remove('ts-selected')


                const prevTitle = prevSelected.querySelector('.ts-title')
                if (prevTitle) {

                }
            }
        }


        this.selectedNodeId = nodeId
        const entry = document.getElementById(nodeId)
        if (entry) {
            entry.classList.add('ts-selected')
        }
    }





    navigateUp(currentNodeId) {
        const currentLi = this.nodeElements.get(currentNodeId)
        if (!currentLi) return


        let prevLi = currentLi.previousElementSibling

        if (prevLi) {

            while (prevLi.classList.contains('ts-open') && prevLi.querySelector('ul')?.lastElementChild) {
                prevLi = prevLi.querySelector('ul').lastElementChild
            }


            const prevId = prevLi.querySelector('.ts-entry').id
            this.selectNode(prevId)
        } else {

            const parentLi = currentLi.parentElement.closest('li')
            if (parentLi) {
                const parentId = parentLi.querySelector('.ts-entry').id
                this.selectNode(parentId)
            }
        }
    }





    navigateDown(currentNodeId) {
        const currentLi = this.nodeElements.get(currentNodeId)
        if (!currentLi) return


        if (currentLi.classList.contains('ts-open')) {
            const firstChild = currentLi.querySelector('ul > li')
            if (firstChild) {
                const childId = firstChild.querySelector('.ts-entry').id
                this.selectNode(childId)
                return
            }
        }


        let nextLi = currentLi.nextElementSibling
        if (nextLi) {
            const nextId = nextLi.querySelector('.ts-entry').id
            this.selectNode(nextId)
            return
        }


        let parent = currentLi.parentElement.closest('li')
        while (parent) {
            const parentNext = parent.nextElementSibling
            if (parentNext) {
                const nextId = parentNext.querySelector('.ts-entry').id
                this.selectNode(nextId)
                return
            }
            parent = parent.parentElement.closest('li')
        }
    }





    showCard(nodeId) {

        const entry = document.getElementById(nodeId)
        if (!entry) return


        const title = entry.querySelector('.ts-title').textContent
        const date = entry.querySelector('.date').textContent


        this.eventBus.publish('view:getNodeData', {
            nodeId,
            callback: (node) => {
                const card = document.getElementById('card')
                const cardTitle = document.getElementById('card-title')
                const cardNid = document.getElementById('card-nid')
                const cardDate = document.getElementById('card-date')
                const cardDescription = document.getElementById('card-description')


                cardTitle.textContent = title
                cardNid.textContent = nodeId
                cardDate.textContent = date


                cardDescription.value = node.description || ''

                // Store node ID with the card
                card.dataset.nodeId = nodeId

                // Show the card
                card.classList.remove('hidden')


                cardDescription.focus()
            }
        })
    }





    handleNodeAdded(data) {
        const { node, parentId } = data


        let parentElement
        if (parentId === 'trestle-root') {
            parentElement = this.rootElement.querySelector('ul')
        } else {
            const parentLi = this.nodeElements.get(parentId)
            if (!parentLi) {
                console.error('Parent not found:', parentId)
                return
            }


            let ul = parentLi.querySelector('ul')
            if (!ul) {
                ul = document.createElement('ul')
                parentLi.appendChild(ul)
                parentLi.classList.remove('ts-closed')
                parentLi.classList.add('ts-open')
            }

            parentElement = ul
        }


        const nodesMap = new Map()
        nodesMap.set(node.id, node)


        const newNodeElement = this.renderNode(node.id, parentElement, nodesMap)


        if (newNodeElement) {
            const titleElement = newNodeElement.querySelector('.ts-title')
            this.selectNode(node.id)


            titleElement.contentEditable = true
            titleElement.focus()


            const range = document.createRange()
            range.selectNodeContents(titleElement)
            const selection = window.getSelection()
            selection.removeAllRanges()
            selection.addRange(range)
        }


        this.initDragAndDrop()
    }





    handleNodeUpdated(data) {
        const { nodeId, properties } = data


        const nodeEntry = document.getElementById(nodeId)
        if (!nodeEntry) return


        if (properties.title !== undefined) {
            const titleElement = nodeEntry.querySelector('.ts-title')
            titleElement.textContent = properties.title
        }


    }





    handleNodeDeleted(data) {
        const { nodeId } = data


        const nodeLi = this.nodeElements.get(nodeId)
        if (nodeLi) {
            nodeLi.remove()
            this.nodeElements.delete(nodeId)
        }
    }
}

================
File: js/config.js
================
export const Config = {


    SPARQL_ENDPOINT: 'https://fuseki.hyperdata.it/farelo',

    BASE_URI: 'http://hyperdata.it/trestle/',



    PREFIXES: {
        dc: 'http://purl.org/dc/terms/',
        ts: 'http://purl.org/stuff/trestle/'
    },


    AUTO_SAVE: false,
    AUTO_SAVE_INTERVAL: 60000,


    KEY_CODES: {
        TAB: 9,
        ENTER: 13,
        ESCAPE: 27,
        UP: 38,
        DOWN: 40
    }
}

================
File: js/main.js
================
import { TrestleModel } from './model/TrestleModel.js'
import { TrestleView } from './view/TrestleView.js'
import { TrestleController } from './controller/TrestleController.js'
import { Config } from './config.js'
import { EventBus } from './utils/EventBus.js'

document.addEventListener('DOMContentLoaded', () => {






    const eventBus = new EventBus()


    const model = new TrestleModel(Config.SPARQL_ENDPOINT, Config.BASE_URI, eventBus)

    const view = new TrestleView(document.getElementById('trestle-root'), eventBus)
    const controller = new TrestleController(model, view, eventBus)


    setupUIListeners(controller)


    controller.initialize()

})





function setupUIListeners(controller) {
    const saveButton = document.getElementById('saveButton')
    const addButton = document.getElementById('addButton')
    const shortcutsButton = document.getElementById('shortcutsButton')
    const cardClose = document.getElementById('card-close')
    const shortcutsText = document.getElementById('shortcuts-text')


    saveButton.addEventListener('click', () => controller.saveData())
    addButton.addEventListener('click', () => controller.addRootItem())
    shortcutsButton.addEventListener('click', () => {
        shortcutsText.classList.toggle('hidden')
    })


    cardClose.addEventListener('click', () => {
        const card = document.getElementById('card')
        const cardDescription = document.getElementById('card-description')


        if (card.dataset.nodeId) {
            controller.updateNodeDescription(card.dataset.nodeId, cardDescription.value)
        }

        card.classList.add('hidden')
    })
}

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trestle - Hierarchical Todo List</title>
    <link rel="stylesheet" href="css/trestle.css">
    <meta name="description" content="Trestle - A hierarchical todo list with SPARQL backend">
</head>

<body>
    <header id="header-outer">
        <div id="header">Trestle</div>
    </header>

    <div id="menu-box">
        <div class="toolbar">
            <ul>
                <li><button id="saveButton">Save</button></li>
                <li><button id="addButton">Add Root Item</button></li>
                <li><button id="shortcutsButton">Shortcuts</button></li>
            </ul>
        </div>
    </div>

    <div id="shortcuts-text" class="text-box hidden">
        <h3>Keyboard Shortcuts</h3>
        <ul>
            <li><strong>Enter</strong>: Insert new item</li>
            <li><strong>Tab</strong>: Indent</li>
            <li><strong>Shift+Tab</strong>: Outdent</li>
            <li><strong>Up/Down</strong>: Navigate</li>
            <li><strong>Click</strong> on item to select</li>
            <li><strong>Double-click</strong> to edit</li>
        </ul>
    </div>

    <div id="container">
        <div class="page">
            <div id="trestle">
                <div id="trestle-root" class="ts-root"></div>
            </div>
        </div>
    </div>

    <div id="card" class="hidden">
        <div id="card-title">Title</div>
        <div id="card-content">
            <textarea id="card-description" placeholder="Add description..."></textarea>
        </div>
        <div id="card-nid" class="date"></div>
        <div id="card-date" class="date"></div>
        <button id="card-close">Close</button>
    </div>

    <template id="entry-template">
        <div class="ts-entry">
            <button class="ts-expander" aria-label="Toggle expand"></button>
            <div class="ts-handle" aria-hidden="true">●⊤</div>
            <div class="ts-title" contenteditable="true"></div>
            <div class="ts-actions">
                <button class="ts-card" aria-label="Show card">📄</button>
                <button class="ts-addChild" aria-label="Add child">➕</button>
                <button class="ts-delete" aria-label="Delete">❌</button>
            </div>
            <span class="date hidden"></span>
        </div>
    </template>


    <script type="module" src="js/main.js"></script>
</body>

</html>

================
File: jsdoc.json
================
{
  "tags": {
    "allowUnknownTags": true,
    "dictionaries": ["jsdoc", "closure"]
  },
  "source": {
    "include": ["js", "README.md"],
    "exclude": ["node_modules"],
    "includePattern": ".+\\.js(doc|x)?$",
    "excludePattern": "(^|\\/|\\\\)_"
  },
  "plugins": [
    "plugins/markdown"
  ],
  "templates": {
    "cleverLinks": false,
    "monospaceLinks": false,
    "default": {
      "outputSourceFiles": true,
      "includeDate": false
    }
  },
  "opts": {
    "destination": "./docs/",
    "encoding": "utf8",
    "recurse": true,
    "template": "node_modules/docdash"
  }
}

================
File: package.json
================
{
  "name": "trestle",
  "version": "0.9.0",
  "description": "A hierarchical todo list with SPARQL backend",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "jasmine",
    "docs": "jsdoc -c jsdoc.json",
    "rp": "repomix -c repomix.config.json ."
  },
  "keywords": [
    "todo",
    "rdf",
    "sparql",
    "outliner",
    "hierarchical"
  ],
  "author": "Danny Ayers",
  "license": "MIT",
  "dependencies": {
    "loglevel": "^1.8.1",
    "marked": "^5.0.0",
    "rdf-ext": "^2.2.0"
  },
  "devDependencies": {
    "chai": "^4.3.7",
    "jasmine": "^4.6.0",
    "jsdoc": "^4.0.2",
    "vite": "^4.3.9"
  }
}

================
File: README.md
================
# Trestle - Modern Hierarchical Todo List

Trestle is a web-based hierarchical todo list application with RDF/SPARQL backend support. It allows you to create, organize, and manage nested tasks with rich text descriptions using markdown.

## Features

- **Hierarchical Structure**: Organize tasks in a tree-like structure with unlimited nesting
- **Drag and Drop**: Easily reorganize tasks by dragging and dropping
- **Keyboard Navigation**: Navigate and edit using keyboard shortcuts
- **Markdown Support**: Write rich task descriptions using markdown
- **SPARQL Backend**: Store your data in a standard RDF triplestore
- **Card View**: View and edit detailed information for each task
- **Responsive Design**: Works on both desktop and mobile devices

## Getting Started

### Prerequisites

- Node.js 16 or later
- A SPARQL endpoint (like Apache Jena Fuseki) for data storage

### Installation

1. Clone the repository:

   ```bash
   git clone https://github.com/yourusername/trestle.git
   cd trestle
   ```

2. Install dependencies:

   ```bash
   npm install
   ```

3. Configure the application:

   - Edit `js/config.js` to set your SPARQL endpoint URL and other preferences

4. Start the development server:

   ```bash
   npm run dev
   ```

5. Build for production:
   ```bash
   npm run build
   ```

## Usage

### Keyboard Shortcuts

- **Enter**: Create a new sibling item
- **Tab**: Indent (make a child of previous item)
- **Shift+Tab**: Outdent (move to parent level)
- **Up/Down**: Navigate through items
- **Click** on an item to select it
- **Double-click** on an item to edit it

### Card View

Click the card icon (📄) next to any item to open its detail card. Here you can add and edit markdown descriptions.

### Drag and Drop

- Drag items using the handle (●) to reposition them
- Drop between items to place as a sibling
- Hold over an item to make the dragged item a child

## Data Model

Trestle uses RDF to represent the data structure with the following predicates:

- `dc:title`: Item title
- `dc:created`: Creation timestamp
- `dc:description`: Markdown description
- `ts:index`: Position in parent's children list
- `ts:parent`: Reference to parent node

## Development

### Project Structure

- `js/model/`: Data model and SPARQL interaction
- `js/view/`: UI rendering and event handling
- `js/controller/`: Application logic
- `js/utils/`: Utility functions and helpers

### Running Tests

```bash
npm test
```

### Generating Documentation

```bash
npm run docs
```

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- Original Trestle concept by Danny Ayers
- Inspired by [Workflowy](https://workflowy.com)

================
File: vite.config.js
================
import { defineConfig } from 'vite';
import { resolve } from 'path';

export default defineConfig({
  base: './',
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: true,
    minify: 'terser',
    target: 'es2018'
  },
  server: {
    port: 3000,
    open: true,
    cors: true
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'js')
    }
  }
});
